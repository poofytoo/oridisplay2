###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        11/Nov/2014  12:37:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\Third_Party\FreeRTOS\Source\list.c
#    Command line =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\Third_Party\FreeRTOS\Source\list.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -D USE_STM32F429I_DISCO -D
#        USE_USB_OTG_HS -D USE_EMBEDDED_PHY -lcN
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\
#        --diag_suppress Pe111,Pa082 -o
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\
#        --debug --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Config\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Devices\STM32F4xx\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\User\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Demo\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Lib\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Test_Program\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\HID\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\Audio\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Common\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\STM32F429i-Discovery\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\fat_fs\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\Config\
#        -Ohs --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\list.lst
#    Object file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\list.o
#
###############################################################################

C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\Third_Party\FreeRTOS\Source\list.c
      1          /*
      2              FreeRTOS V7.1.1 - Copyright (C) 2012 Real Time Engineers Ltd.
      3          
      4          
      5              ***************************************************************************
      6               *                                                                       *
      7               *    FreeRTOS tutorial books are available in pdf and paperback.        *
      8               *    Complete, revised, and edited pdf reference manuals are also       *
      9               *    available.                                                         *
     10               *                                                                       *
     11               *    Purchasing FreeRTOS documentation will not only help you, by       *
     12               *    ensuring you get running as quickly as possible and with an        *
     13               *    in-depth knowledge of how to use FreeRTOS, it will also help       *
     14               *    the FreeRTOS project to continue with its mission of providing     *
     15               *    professional grade, cross platform, de facto standard solutions    *
     16               *    for microcontrollers - completely free of charge!                  *
     17               *                                                                       *
     18               *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
     19               *                                                                       *
     20               *    Thank you for using FreeRTOS, and thank you for your support!      *
     21               *                                                                       *
     22              ***************************************************************************
     23          
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              >>>NOTE<<< The modification to the GPL is included to allow you to
     31              distribute a combined work that includes FreeRTOS without being obliged to
     32              provide the source code for proprietary components outside of the FreeRTOS
     33              kernel.  FreeRTOS is distributed in the hope that it will be useful, but
     34              WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     35              or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43              
     44              ***************************************************************************
     45               *                                                                       *
     46               *    Having a problem?  Start by reading the FAQ "My application does   *
     47               *    not run, what could be wrong?                                      *
     48               *                                                                       *
     49               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     50               *                                                                       *
     51              ***************************************************************************
     52          
     53              
     54              http://www.FreeRTOS.org - Documentation, training, latest information, 
     55              license and contact details.
     56              
     57              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     58              including FreeRTOS+Trace - an indispensable productivity tool.
     59          
     60              Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell 
     61              the code with commercial support, indemnification, and middleware, under 
     62              the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
     63              provide a safety engineered and independently SIL3 certified version under 
     64              the SafeRTOS brand: http://www.SafeRTOS.com.
     65          */
     66          
     67          
     68          #include <stdlib.h>
     69          #include "FreeRTOS.h"
     70          #include "list.h"
     71          
     72          /*-----------------------------------------------------------
     73           * PUBLIC LIST API documented in list.h
     74           *----------------------------------------------------------*/
     75          
     76          void vListInitialise( xList *pxList )
     77          {
     78          	/* The list structure contains a list item which is used to mark the
     79          	end of the list.  To initialise the list the list end is inserted
     80          	as the only list entry. */
     81          	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     82          
     83          	/* The list end value is the highest possible value in the list to
     84          	ensure it remains at the end of the list. */
     85          	pxList->xListEnd.xItemValue = portMAX_DELAY;
     86          
     87          	/* The list end next and previous pointers point to itself so we know
     88          	when the list is empty. */
     89          	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     90          	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     91          
     92          	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     93          }
     94          /*-----------------------------------------------------------*/
     95          
     96          void vListInitialiseItem( xListItem *pxItem )
     97          {
     98          	/* Make sure the list item is not recorded as being on a list. */
     99          	pxItem->pvContainer = NULL;
    100          }
    101          /*-----------------------------------------------------------*/
    102          
    103          void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
    104          {
    105          volatile xListItem * pxIndex;
    106          
    107          	/* Insert a new list item into pxList, but rather than sort the list,
    108          	makes the new list item the last item to be removed by a call to
    109          	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
    110          	the pxIndex member. */
    111          	pxIndex = pxList->pxIndex;
    112          
    113          	pxNewListItem->pxNext = pxIndex->pxNext;
    114          	pxNewListItem->pxPrevious = pxList->pxIndex;
    115          	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    116          	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    117          	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    118          
    119          	/* Remember which list the item is in. */
    120          	pxNewListItem->pvContainer = ( void * ) pxList;
    121          
    122          	( pxList->uxNumberOfItems )++;
    123          }
    124          /*-----------------------------------------------------------*/
    125          
    126          void vListInsert( xList *pxList, xListItem *pxNewListItem )
    127          {
    128          volatile xListItem *pxIterator;
    129          portTickType xValueOfInsertion;
    130          
    131          	/* Insert the new list item into the list, sorted in ulListItem order. */
    132          	xValueOfInsertion = pxNewListItem->xItemValue;
    133          
    134          	/* If the list already contains a list item with the same item value then
    135          	the new list item should be placed after it.  This ensures that TCB's which
    136          	are stored in ready lists (all of which have the same ulListItem value)
    137          	get an equal share of the CPU.  However, if the xItemValue is the same as
    138          	the back marker the iteration loop below will not end.  This means we need
    139          	to guard against this by checking the value first and modifying the
    140          	algorithm slightly if necessary. */
    141          	if( xValueOfInsertion == portMAX_DELAY )
    142          	{
    143          		pxIterator = pxList->xListEnd.pxPrevious;
    144          	}
    145          	else
    146          	{
    147          		/* *** NOTE ***********************************************************
    148          		If you find your application is crashing here then likely causes are:
    149          			1) Stack overflow -
    150          			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
    151          			2) Incorrect interrupt priority assignment, especially on Cortex-M3
    152          			   parts where numerically high priority values denote low actual
    153          			   interrupt priories, which can seem counter intuitive.  See
    154          			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
    155          			3) Calling an API function from within a critical section or when
    156          			   the scheduler is suspended.
    157          			4) Using a queue or semaphore before it has been initialised or
    158          			   before the scheduler has been started (are interrupts firing
    159          			   before vTaskStartScheduler() has been called?).
    160          		See http://www.freertos.org/FAQHelp.html for more tips.
    161          		**********************************************************************/
    162          		
    163          		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    164          		{
    165          			/* There is nothing to do here, we are just iterating to the
    166          			wanted insertion position. */
    167          		}
    168          	}
    169          
    170          	pxNewListItem->pxNext = pxIterator->pxNext;
    171          	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    172          	pxNewListItem->pxPrevious = pxIterator;
    173          	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    174          
    175          	/* Remember which list the item is in.  This allows fast removal of the
    176          	item later. */
    177          	pxNewListItem->pvContainer = ( void * ) pxList;
    178          
    179          	( pxList->uxNumberOfItems )++;
    180          }
    181          /*-----------------------------------------------------------*/
    182          
    183          void vListRemove( xListItem *pxItemToRemove )
    184          {
    185          xList * pxList;
    186          
    187          	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    188          	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    189          	
    190          	/* The list item knows which list it is in.  Obtain the list from the list
    191          	item. */
    192          	pxList = ( xList * ) pxItemToRemove->pvContainer;
    193          
    194          	/* Make sure the index is left pointing to a valid item. */
    195          	if( pxList->pxIndex == pxItemToRemove )
    196          	{
    197          		pxList->pxIndex = pxItemToRemove->pxPrevious;
    198          	}
    199          
    200          	pxItemToRemove->pvContainer = NULL;
    201          	( pxList->uxNumberOfItems )--;
    202          }
    203          /*-----------------------------------------------------------*/
    204          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   vListInitialise
       0   vListInitialiseItem
       0   vListInsert
       0   vListInsertEnd
       0   vListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      26  vListInitialise
       6  vListInitialiseItem
     104  vListInsert
      28  vListInsertEnd
      36  vListRemove

 
 200 bytes in section .text
 
 200 bytes of CODE memory

Errors: none
Warnings: none
