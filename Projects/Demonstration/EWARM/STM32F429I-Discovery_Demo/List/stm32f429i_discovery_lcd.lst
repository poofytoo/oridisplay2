###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        23/Nov/2014  02:55:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\STM32F429I-Discovery\stm32f429i_discovery_lcd.c
#    Command line =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\STM32F429I-Discovery\stm32f429i_discovery_lcd.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -D USE_STM32F429I_DISCO -D
#        USE_USB_OTG_HS -D USE_EMBEDDED_PHY -lcN
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\
#        --diag_suppress Pe111,Pa082 -o
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\
#        --debug --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Config\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Devices\STM32F4xx\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\User\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Demo\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Lib\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Test_Program\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\HID\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\Audio\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Common\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\STM32F429i-Discovery\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\fat_fs\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\Config\
#        -Ohs --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\stm32f429i_discovery_lcd.lst
#    Object file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\stm32f429i_discovery_lcd.o
#
###############################################################################

C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Utilities\STM32F429I-Discovery\stm32f429i_discovery_lcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f429i_discovery_lcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    28-October-2013
      7            * @brief   This file includes the LCD driver for ILI9341 Liquid Crystal 
      8            *          Display Modules of STM32F429I-DISCO kit (MB1075).
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */
     28          
     29          /* Includes ------------------------------------------------------------------*/
     30          #include "stm32f429i_discovery_lcd.h"
     31          #include "../Common/fonts.c"
     32          
     33          
     34          /** @addtogroup Utilities
     35            * @{
     36            */ 
     37          
     38          /** @addtogroup STM32F4_DISCOVERY
     39            * @{
     40            */ 
     41          
     42          /** @addtogroup STM32F429I_DISCOVERY
     43            * @{
     44            */
     45              
     46          /** @defgroup STM32F429I_DISCOVERY_LCD 
     47            * @brief This file includes the LCD driver for (ILI9341) 
     48            * @{
     49            */ 
     50          
     51          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_TypesDefinitions
     52            * @{
     53            */ 
     54          /**
     55            * @}
     56            */ 
     57          
     58          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_Defines
     59            * @{
     60            */
     61          
     62          #define POLY_Y(Z)          ((int32_t)((Points + Z)->X))
     63          #define POLY_X(Z)          ((int32_t)((Points + Z)->Y))   
     64          /**
     65            * @}
     66            */ 
     67          
     68          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_Macros
     69            * @{
     70            */
     71          #define ABS(X)  ((X) > 0 ? (X) : -(X))    
     72          /**
     73            * @}
     74            */ 
     75            
     76          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_Variables
     77            * @{
     78            */ 
     79          static sFONT *LCD_Currentfonts;
     80          /* Global variables to set the written text color */
     81          static uint16_t CurrentTextColor   = 0x0000;
     82          static uint16_t CurrentBackColor   = 0xFFFF;
     83          /* Default LCD configuration with LCD Layer 1 */
     84          static uint32_t CurrentFrameBuffer = LCD_FRAME_BUFFER;
     85          static uint32_t CurrentLayer = LCD_BACKGROUND_LAYER;
     86          /**
     87            * @}
     88            */ 
     89          
     90          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_FunctionPrototypes
     91            * @{
     92            */ 
     93          #ifndef USE_Delay
     94          static void delay(__IO uint32_t nCount);
     95          #endif /* USE_Delay*/
     96          
     97          static void PutPixel(int16_t x, int16_t y);
     98          static void LCD_PolyLineRelativeClosed(pPoint Points, uint16_t PointCount, uint16_t Closed);
     99          static void LCD_AF_GPIOConfig(void);
    100          
    101          /**
    102            * @}
    103            */ 
    104          
    105          /** @defgroup STM32F429I_DISCOVERY_LCD_Private_Functions
    106            * @{
    107            */ 
    108          
    109          /**
    110            * @brief  DeInitializes the LCD.
    111            * @param  None
    112            * @retval None
    113            */
    114          void LCD_DeInit(void)
    115          { 
    116            GPIO_InitTypeDef GPIO_InitStructure;
    117          
    118            /* LCD Display Off */
    119            LCD_DisplayOff();
    120          
    121            /* LCD_SPI disable */
    122            SPI_Cmd(LCD_SPI, DISABLE);
    123            
    124            /* LCD_SPI DeInit */
    125            SPI_I2S_DeInit(LCD_SPI);
    126             
    127            /* Disable SPI clock  */
    128            RCC_APB2PeriphClockCmd(LCD_SPI_CLK, DISABLE);
    129              
    130            /* Configure NCS in Output Push-Pull mode */
    131            GPIO_InitStructure.GPIO_Pin = LCD_NCS_PIN;
    132            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    133            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    134            GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
    135             
    136            /* Configure SPI pins: SCK, MISO and MOSI */
    137            GPIO_InitStructure.GPIO_Pin = LCD_SPI_SCK_PIN;
    138            GPIO_Init(LCD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
    139          
    140            GPIO_InitStructure.GPIO_Pin = LCD_SPI_MISO_PIN;
    141            GPIO_Init(LCD_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
    142            
    143            GPIO_InitStructure.GPIO_Pin = LCD_SPI_MOSI_PIN;
    144            GPIO_Init(LCD_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
    145          
    146            /* GPIOA configuration */
    147            GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_MCO);
    148            GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_MCO);
    149            GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_MCO);
    150            GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_MCO);
    151            GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_MCO);
    152            
    153            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 |
    154                                          GPIO_Pin_11 | GPIO_Pin_12;
    155            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    156            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    157            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    158            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    159            GPIO_Init(GPIOA, &GPIO_InitStructure);
    160          
    161            /* GPIOB configuration */
    162            GPIO_PinAFConfig(GPIOB, GPIO_PinSource0, GPIO_AF_MCO);
    163            GPIO_PinAFConfig(GPIOB, GPIO_PinSource1, GPIO_AF_MCO);
    164            GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_MCO);
    165            GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_MCO);
    166            GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_MCO);
    167            GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_MCO);
    168            
    169            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_8    |
    170                                          GPIO_Pin_9  |  GPIO_Pin_10 | GPIO_Pin_11;
    171            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    172            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    173            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    174            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    175            GPIO_Init(GPIOB, &GPIO_InitStructure);
    176            
    177            /* GPIOC configuration */
    178            GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_MCO);
    179            GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_MCO);
    180            GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_MCO);
    181            
    182            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6  | GPIO_Pin_7  | GPIO_Pin_10;
    183            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    184            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    185            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    186            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    187            GPIO_Init(GPIOC, &GPIO_InitStructure);
    188            
    189            /* GPIOD configuration */
    190            GPIO_PinAFConfig(GPIOD, GPIO_PinSource3, GPIO_AF_MCO);
    191            GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_MCO);
    192            
    193            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3  | GPIO_Pin_6; 
    194            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    195            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    196            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    197            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    198            GPIO_Init(GPIOD, &GPIO_InitStructure);  
    199          
    200            /* GPIOF configuration */
    201            GPIO_PinAFConfig(GPIOF, GPIO_PinSource10, GPIO_AF_MCO);
    202            
    203            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; 
    204            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    205            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    206            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    207            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    208            GPIO_Init(GPIOF, &GPIO_InitStructure);  
    209          
    210            /* GPIOG configuration */
    211            GPIO_PinAFConfig(GPIOG, GPIO_PinSource6, GPIO_AF_MCO);
    212            GPIO_PinAFConfig(GPIOG, GPIO_PinSource7, GPIO_AF_MCO);
    213            GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, GPIO_AF_MCO);
    214            GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_MCO);
    215            GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_MCO);
    216            
    217            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6  | GPIO_Pin_7  | GPIO_Pin_10    |
    218                                          GPIO_Pin_11 | GPIO_Pin_12;
    219            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    220            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    221            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    222            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    223            GPIO_Init(GPIOG, &GPIO_InitStructure);
    224          }
    225          
    226          /**
    227            * @brief  Initializes the LCD.
    228            * @param  None
    229            * @retval None
    230            */
    231          void LCD_Init(void)
    232          { 
    233            LTDC_InitTypeDef       LTDC_InitStruct;
    234            
    235            /* Configure the LCD Control pins ------------------------------------------*/
    236            LCD_CtrlLinesConfig();
    237            LCD_ChipSelect(DISABLE);
    238            LCD_ChipSelect(ENABLE);
    239            
    240            /* Configure the LCD_SPI interface -----------------------------------------*/
    241            LCD_SPIConfig(); 
    242            
    243            /* Power on the LCD --------------------------------------------------------*/
    244            LCD_PowerOn();
    245            
    246            /* Enable the LTDC Clock */
    247            RCC_APB2PeriphClockCmd(RCC_APB2Periph_LTDC, ENABLE);
    248            
    249            /* Enable the DMA2D Clock */
    250            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2D, ENABLE); 
    251            
    252            /* Configure the LCD Control pins */
    253            LCD_AF_GPIOConfig();  
    254            
    255            /* Configure the FMC Parallel interface : SDRAM is used as Frame Buffer for LCD */
    256            SDRAM_Init();
    257            
    258            /* LTDC Configuration *********************************************************/  
    259            /* Polarity configuration */
    260            /* Initialize the horizontal synchronization polarity as active low */
    261            LTDC_InitStruct.LTDC_HSPolarity = LTDC_HSPolarity_AL;     
    262            /* Initialize the vertical synchronization polarity as active low */  
    263            LTDC_InitStruct.LTDC_VSPolarity = LTDC_VSPolarity_AL;     
    264            /* Initialize the data enable polarity as active low */
    265            LTDC_InitStruct.LTDC_DEPolarity = LTDC_DEPolarity_AL;     
    266            /* Initialize the pixel clock polarity as input pixel clock */ 
    267            LTDC_InitStruct.LTDC_PCPolarity = LTDC_PCPolarity_IPC;
    268            
    269            /* Configure R,G,B component values for LCD background color */                   
    270            LTDC_InitStruct.LTDC_BackgroundRedValue = 0;            
    271            LTDC_InitStruct.LTDC_BackgroundGreenValue = 0;          
    272            LTDC_InitStruct.LTDC_BackgroundBlueValue = 0;  
    273            
    274            /* Configure PLLSAI prescalers for LCD */
    275            /* Enable Pixel Clock */
    276            /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
    277            /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAI_N = 192 Mhz */
    278            /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAI_R = 192/4 = 48 Mhz */
    279            /* LTDC clock frequency = PLLLCDCLK / RCC_PLLSAIDivR = 48/8 = 6 Mhz */
    280            RCC_PLLSAIConfig(192, 7, 4);
    281            RCC_LTDCCLKDivConfig(RCC_PLLSAIDivR_Div8);
    282            
    283            /* Enable PLLSAI Clock */
    284            RCC_PLLSAICmd(ENABLE);
    285            /* Wait for PLLSAI activation */
    286            while(RCC_GetFlagStatus(RCC_FLAG_PLLSAIRDY) == RESET)
    287            {
    288            }
    289            
    290            /* Timing configuration */  
    291            /* Configure horizontal synchronization width */     
    292            LTDC_InitStruct.LTDC_HorizontalSync = 1;//9;
    293            /* Configure vertical synchronization height */
    294            LTDC_InitStruct.LTDC_VerticalSync = 9;//1;
    295            /* Configure accumulated horizontal back porch */
    296            LTDC_InitStruct.LTDC_AccumulatedHBP = 3;//29; 
    297            /* Configure accumulated vertical back porch */
    298            LTDC_InitStruct.LTDC_AccumulatedVBP = 29;//3;  
    299            /* Configure accumulated active width */  
    300            LTDC_InitStruct.LTDC_AccumulatedActiveW = 323;//269;
    301            /* Configure accumulated active height */
    302            LTDC_InitStruct.LTDC_AccumulatedActiveH = 269;//323;
    303            /* Configure total width */
    304            LTDC_InitStruct.LTDC_TotalWidth = 327;//279; 
    305            /* Configure total height */
    306            LTDC_InitStruct.LTDC_TotalHeigh = 279;//327;
    307            
    308            LTDC_Init(&LTDC_InitStruct);
    309          }  
    310          
    311          /**
    312            * @brief  Initializes the LCD Layers.
    313            * @param  None
    314            * @retval None
    315            */
    316          void LCD_LayerInit(void)
    317          {
    318            LTDC_Layer_InitTypeDef LTDC_Layer_InitStruct; 
    319            
    320            /* Windowing configuration */
    321            /* In this case all the active display area is used to display a picture then :
    322            Horizontal start = horizontal synchronization + Horizontal back porch = 30 
    323            Horizontal stop = Horizontal start + window width -1 = 30 + 240 -1
    324            Vertical start   = vertical synchronization + vertical back porch     = 4
    325            Vertical stop   = Vertical start + window height -1  = 4 + 320 -1      */      
    326            LTDC_Layer_InitStruct.LTDC_HorizontalStart = 4; //30;
    327            LTDC_Layer_InitStruct.LTDC_HorizontalStop = (LCD_PIXEL_WIDTH + 4 - 1);//30 - 1); 
    328            LTDC_Layer_InitStruct.LTDC_VerticalStart = 30; // 4;
    329            LTDC_Layer_InitStruct.LTDC_VerticalStop = (LCD_PIXEL_HEIGHT + 30 - 1);//4 - 1);
    330            
    331            /* Pixel Format configuration*/
    332            LTDC_Layer_InitStruct.LTDC_PixelFormat = LTDC_Pixelformat_RGB565;
    333            /* Alpha constant (255 totally opaque) */
    334            LTDC_Layer_InitStruct.LTDC_ConstantAlpha = 255; 
    335            /* Default Color configuration (configure A,R,G,B component values) */          
    336            LTDC_Layer_InitStruct.LTDC_DefaultColorBlue = 0;        
    337            LTDC_Layer_InitStruct.LTDC_DefaultColorGreen = 0;       
    338            LTDC_Layer_InitStruct.LTDC_DefaultColorRed = 0;         
    339            LTDC_Layer_InitStruct.LTDC_DefaultColorAlpha = 0;
    340            /* Configure blending factors */       
    341            LTDC_Layer_InitStruct.LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_CA;    
    342            LTDC_Layer_InitStruct.LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_CA;
    343            
    344            /* the length of one line of pixels in bytes + 3 then :
    345            Line Lenth = Active high width x number of bytes per pixel + 3 
    346            Active high width         = LCD_PIXEL_WIDTH 
    347            number of bytes per pixel = 2    (pixel_format : RGB565) 
    348            */
    349            LTDC_Layer_InitStruct.LTDC_CFBLineLength = ((LCD_PIXEL_WIDTH * 2) + 3);
    350            /* the pitch is the increment from the start of one line of pixels to the 
    351            start of the next line in bytes, then :
    352            Pitch = Active high width x number of bytes per pixel */ 
    353            LTDC_Layer_InitStruct.LTDC_CFBPitch = (LCD_PIXEL_WIDTH * 2);
    354            
    355            /* Configure the number of lines */  
    356            LTDC_Layer_InitStruct.LTDC_CFBLineNumber = LCD_PIXEL_HEIGHT;
    357            
    358            /* Start Address configuration : the LCD Frame buffer is defined on SDRAM */    
    359            LTDC_Layer_InitStruct.LTDC_CFBStartAdress = LCD_FRAME_BUFFER;
    360            
    361            /* Initialize LTDC layer 1 */
    362            LTDC_LayerInit(LTDC_Layer1, &LTDC_Layer_InitStruct);
    363            
    364            /* Configure Layer2 */
    365            /* Start Address configuration : the LCD Frame buffer is defined on SDRAM w/ Offset */     
    366            LTDC_Layer_InitStruct.LTDC_CFBStartAdress = LCD_FRAME_BUFFER + BUFFER_OFFSET;
    367            
    368            /* Configure blending factors */       
    369            LTDC_Layer_InitStruct.LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_PAxCA;    
    370            LTDC_Layer_InitStruct.LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_PAxCA;
    371            
    372            /* Initialize LTDC layer 2 */
    373            LTDC_LayerInit(LTDC_Layer2, &LTDC_Layer_InitStruct);
    374            
    375            /* LTDC configuration reload */  
    376            LTDC_ReloadConfig(LTDC_IMReload);
    377            
    378            /* Enable foreground & background Layers */
    379            LTDC_LayerCmd(LTDC_Layer1, ENABLE); 
    380            LTDC_LayerCmd(LTDC_Layer2, ENABLE);
    381            
    382            /* LTDC configuration reload */  
    383            LTDC_ReloadConfig(LTDC_IMReload);
    384            
    385            /* Set default font */    
    386            LCD_SetFont(&LCD_DEFAULT_FONT); 
    387            
    388            /* dithering activation */
    389            LTDC_DitherCmd(ENABLE);
    390          }
    391          
    392          /**
    393            * @brief  Controls LCD Chip Select (CS) pin
    394            * @param  NewState CS pin state
    395            * @retval None
    396            */
    397          void LCD_ChipSelect(FunctionalState NewState)
    398          {
    399            if (NewState == DISABLE)
    400            {
    401              GPIO_ResetBits(LCD_NCS_GPIO_PORT, LCD_NCS_PIN); /* CS pin low: LCD disabled */
    402            }
    403            else
    404            {
    405              GPIO_SetBits(LCD_NCS_GPIO_PORT, LCD_NCS_PIN); /* CS pin high: LCD enabled */
    406            }
    407          }
    408          
    409          /**
    410            * @brief  Sets the LCD Layer.
    411            * @param  Layerx: specifies the Layer foreground or background.
    412            * @retval None
    413            */
    414          void LCD_SetLayer(uint32_t Layerx)
    415          {
    416            if (Layerx == LCD_BACKGROUND_LAYER)
    417            {
    418              CurrentFrameBuffer = LCD_FRAME_BUFFER; 
    419              CurrentLayer = LCD_BACKGROUND_LAYER;
    420            }
    421            else
    422            {
    423              CurrentFrameBuffer = LCD_FRAME_BUFFER + BUFFER_OFFSET;
    424              CurrentLayer = LCD_FOREGROUND_LAYER;
    425            }
    426          }  
    427          
    428          /**
    429            * @brief  Sets the LCD Text and Background colors.
    430            * @param  TextColor: specifies the Text Color.
    431            * @param  BackColor: specifies the Background Color.
    432            * @retval None
    433            */
    434          void LCD_SetColors(uint16_t TextColor, uint16_t BackColor)
    435          {
    436            CurrentTextColor = TextColor; 
    437            CurrentBackColor = BackColor;
    438          }
    439          
    440          /**
    441            * @brief  Gets the LCD Text and Background colors.
    442            * @param  TextColor: pointer to the variable that will contain the Text 
    443                      Color.
    444            * @param  BackColor: pointer to the variable that will contain the Background 
    445                      Color.
    446            * @retval None
    447            */
    448          void LCD_GetColors(uint16_t *TextColor, uint16_t *BackColor)
    449          {
    450            *TextColor = CurrentTextColor;
    451            *BackColor = CurrentBackColor;
    452          }
    453          
    454          /**
    455            * @brief  Sets the Text color.
    456            * @param  Color: specifies the Text color code RGB(5-6-5).
    457            * @retval None
    458            */
    459          void LCD_SetTextColor(uint16_t Color)
    460          {
    461            CurrentTextColor = Color;
    462          }
    463          
    464          /**
    465            * @brief  Sets the Background color.
    466            * @param  Color: specifies the Background color code RGB(5-6-5).
    467            * @retval None
    468            */
    469          void LCD_SetBackColor(uint16_t Color)
    470          {
    471            CurrentBackColor = Color;
    472          }
    473          
    474          /**
    475            * @brief  Sets the Text Font.
    476            * @param  fonts: specifies the font to be used.
    477            * @retval None
    478            */
    479          void LCD_SetFont(sFONT *fonts)
    480          {
    481            LCD_Currentfonts = fonts;
    482          }
    483          
    484          /**
    485            * @brief  Configure the transparency.
    486            * @param  transparency: specifies the transparency, 
    487            *         This parameter must range from 0x00 to 0xFF.
    488            * @retval None
    489            */
    490          void LCD_SetTransparency(uint8_t transparency)
    491          {
    492            if (CurrentLayer == LCD_BACKGROUND_LAYER)
    493            {
    494              LTDC_LayerAlpha(LTDC_Layer1, transparency);
    495            }
    496            else
    497            {     
    498              LTDC_LayerAlpha(LTDC_Layer2, transparency);
    499            }
    500            LTDC_ReloadConfig(LTDC_IMReload);
    501          }
    502          
    503          /**
    504            * @brief  Gets the Text Font.
    505            * @param  None.
    506            * @retval the used font.
    507            */
    508          sFONT *LCD_GetFont(void)
    509          {
    510            return LCD_Currentfonts;
    511          }
    512          
    513          /**
    514            * @brief  Clears the selected line.
    515            * @param  Line: the Line to be cleared.
    516            *   This parameter can be one of the following values:
    517            *     @arg LCD_LINE_x: where x can be: 0..13 if LCD_Currentfonts is Font16x24
    518            *                                      0..26 if LCD_Currentfonts is Font12x12 or Font8x12
    519            *                                      0..39 if LCD_Currentfonts is Font8x8
    520            * @retval None
    521            */
    522          void LCD_ClearLine(uint16_t Line)
    523          {
    524            uint16_t refcolumn = 0;
    525            /* Send the string character by character on lCD */
    526            while ((refcolumn < LCD_PIXEL_WIDTH) && (((refcolumn + LCD_Currentfonts->Width)& 0xFFFF) >= LCD_Currentfonts->Width))
    527            {
    528              /* Display one character on LCD */
    529              LCD_DisplayChar(Line, refcolumn, ' ');
    530              /* Decrement the column position by 16 */
    531              refcolumn += LCD_Currentfonts->Width;
    532            }
    533          }
    534          
    535          /**
    536            * @brief  Clears the hole LCD.
    537            * @param  Color: the color of the background.
    538            * @retval None
    539            */
    540          void LCD_Clear(uint16_t Color)
    541          {
    542            uint32_t index = 0;
    543            
    544            /* erase memory */
    545            for (index = 0x00; index < BUFFER_OFFSET; index++)
    546            {
    547              *(__IO uint16_t*)(CurrentFrameBuffer + (2*index)) = Color;
    548            } 
    549          }
    550          
    551          /**
    552            * @brief  Sets the cursor position.
    553            * @param  Xpos: specifies the X position.
    554            * @param  Ypos: specifies the Y position. 
    555            * @retval Display Address
    556            */
    557          uint32_t LCD_SetCursor(uint16_t Xpos, uint16_t Ypos)
    558          {  
    559            return CurrentFrameBuffer + 2*(Xpos + (LCD_PIXEL_WIDTH*Ypos));
    560          }
    561          
    562          /**
    563            * @brief  Config and Sets the color Keying.
    564            * @param  RGBValue: Specifies the Color reference. 
    565            * @retval None
    566            */
    567          void LCD_SetColorKeying(uint32_t RGBValue)
    568          {  
    569            LTDC_ColorKeying_InitTypeDef   LTDC_colorkeying_InitStruct;
    570            
    571            /* configure the color Keying */
    572            LTDC_colorkeying_InitStruct.LTDC_ColorKeyBlue = 0x0000FF & RGBValue;
    573            LTDC_colorkeying_InitStruct.LTDC_ColorKeyGreen = (0x00FF00 & RGBValue) >> 8;
    574            LTDC_colorkeying_InitStruct.LTDC_ColorKeyRed = (0xFF0000 & RGBValue) >> 16;  
    575          
    576            if (CurrentLayer == LCD_BACKGROUND_LAYER)
    577            {   
    578              /* Enable the color Keying for Layer1 */
    579              LTDC_ColorKeyingConfig(LTDC_Layer1, &LTDC_colorkeying_InitStruct, ENABLE);
    580              LTDC_ReloadConfig(LTDC_IMReload);
    581            }
    582            else
    583            {
    584              /* Enable the color Keying for Layer2 */
    585              LTDC_ColorKeyingConfig(LTDC_Layer2, &LTDC_colorkeying_InitStruct, ENABLE);
    586              LTDC_ReloadConfig(LTDC_IMReload);
    587            }
    588          }
    589          
    590          /**
    591            * @brief  Disable the color Keying.
    592            * @param  RGBValue: Specifies the Color reference. 
    593            * @retval None
    594            */
    595          void LCD_ReSetColorKeying(void)
    596          {
    597            LTDC_ColorKeying_InitTypeDef   LTDC_colorkeying_InitStruct;
    598            
    599            if (CurrentLayer == LCD_BACKGROUND_LAYER)
    600            {   
    601              /* Disable the color Keying for Layer1 */
    602              LTDC_ColorKeyingConfig(LTDC_Layer1, &LTDC_colorkeying_InitStruct, DISABLE);
    603              LTDC_ReloadConfig(LTDC_IMReload);
    604            }
    605            else
    606            {
    607              /* Disable the color Keying for Layer2 */
    608              LTDC_ColorKeyingConfig(LTDC_Layer2, &LTDC_colorkeying_InitStruct, DISABLE);
    609              LTDC_ReloadConfig(LTDC_IMReload);
    610            }
    611          } 
    612          
    613          /**
    614            * @brief  Draws a character on LCD.
    615            * @param  Xpos: the Line where to display the character shape.
    616            * @param  Ypos: start column address.
    617            * @param  c: pointer to the character data.
    618            * @retval None
    619            */
    620          void LCD_DrawChar(uint16_t Xpos, uint16_t Ypos, const uint16_t *c)
    621          {
    622            uint32_t index = 0, counter = 0, xpos =0;
    623            uint32_t  Xaddress = 0;
    624            
    625            xpos = Xpos*LCD_PIXEL_WIDTH*2;
    626            Xaddress += Ypos;
    627            
    628            for(index = 0; index < LCD_Currentfonts->Height; index++)
    629            {
    630              
    631              for(counter = 0; counter < LCD_Currentfonts->Width; counter++)
    632              {
    633                    
    634                if((((c[index] & ((0x80 << ((LCD_Currentfonts->Width / 12 ) * 8 ) ) >> counter)) == 0x00) &&(LCD_Currentfonts->Width <= 12))||
    635                  (((c[index] & (0x1 << counter)) == 0x00)&&(LCD_Currentfonts->Width > 12 )))
    636                {
    637                    /* Write data value to all SDRAM memory */
    638                   // *(__IO uint16_t*) (CurrentFrameBuffer + (2*Xaddress) + xpos) = CurrentBackColor;
    639                }
    640                else
    641                {
    642                    /* Write data value to all SDRAM memory */
    643                   *(__IO uint16_t*) (CurrentFrameBuffer + (2*Xaddress) + xpos) = CurrentTextColor;         
    644                }
    645                Xaddress++;
    646              }
    647                Xaddress += (LCD_PIXEL_WIDTH - LCD_Currentfonts->Width);
    648            }
    649          }
    650          
    651          /**
    652            * @brief  Displays one character (16dots width, 24dots height).
    653            * @param  Line: the Line where to display the character shape .
    654            *   This parameter can be one of the following values:
    655            *     @arg Linex: where x can be 0..29
    656            * @param  Column: start column address.
    657            * @param  Ascii: character ascii code, must be between 0x20 and 0x7E.
    658            * @retval None
    659            */
    660          void LCD_DisplayChar(uint16_t Line, uint16_t Column, uint8_t Ascii)
    661          {
    662            Ascii -= 32;
    663          
    664            LCD_DrawChar(Line, Column, &LCD_Currentfonts->table[Ascii * LCD_Currentfonts->Height]);
    665          }
    666          
    667          /**
    668            * @brief  Displays a maximum of 20 char on the LCD.
    669            * @param  Line: the Line where to display the character shape .
    670            *   This parameter can be one of the following values:
    671            *     @arg Linex: where x can be 0..9
    672            * @param  *ptr: pointer to string to display on LCD.
    673            * @retval None
    674            */
    675          void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr)
    676          {  
    677            uint16_t refcolumn = 0;
    678            /* Send the string character by character on lCD */
    679            while ((refcolumn < LCD_PIXEL_WIDTH) && ((*ptr != 0) & (((refcolumn + LCD_Currentfonts->Width) & 0xFFFF) >= LCD_Currentfonts->Width)))
    680            {
    681              /* Display one character on LCD */
    682              LCD_DisplayChar(Line, refcolumn, *ptr);
    683              /* Decrement the column position by width */
    684              refcolumn += LCD_Currentfonts->Width;
    685              /* Point on the next character */
    686              ptr++;
    687            }
    688          }
    689          
    690          /**
    691            * @brief  Sets a display window
    692            * @param  Xpos: specifies the X bottom left position from 0 to 240.
    693            * @param  Ypos: specifies the Y bottom left position from 0 to 320.
    694            * @param  Height: display window height, can be a value from 0 to 320.
    695            * @param  Width: display window width, can be a value from 0 to 240.
    696            * @retval None
    697            */
    698          void LCD_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Height, uint16_t Width)
    699          {
    700          
    701            if (CurrentLayer == LCD_BACKGROUND_LAYER)
    702            { 
    703              /* reconfigure the layer1 position */
    704              LTDC_LayerPosition(LTDC_Layer1, Xpos, Ypos);
    705              LTDC_ReloadConfig(LTDC_IMReload);
    706              
    707              /* reconfigure the layer1 size */
    708              LTDC_LayerSize(LTDC_Layer1, Width, Height);
    709              LTDC_ReloadConfig(LTDC_IMReload);
    710           }
    711           else
    712           {   
    713              /* reconfigure the layer2 position */
    714              LTDC_LayerPosition(LTDC_Layer2, Xpos, Ypos);
    715              LTDC_ReloadConfig(LTDC_IMReload); 
    716             
    717             /* reconfigure the layer2 size */
    718              LTDC_LayerSize(LTDC_Layer2, Width, Height);
    719              LTDC_ReloadConfig(LTDC_IMReload);
    720            }
    721          }
    722          
    723          /**
    724            * @brief  Disables LCD Window mode.
    725            * @param  None
    726            * @retval None
    727            */
    728          void LCD_WindowModeDisable(void)
    729          {
    730            LCD_SetDisplayWindow(0, 0, LCD_PIXEL_HEIGHT, LCD_PIXEL_WIDTH); 
    731          }
    732          
    733          /**
    734            * @brief  Displays a line.
    735            * @param Xpos: specifies the X position, can be a value from 0 to 240.
    736            * @param Ypos: specifies the Y position, can be a value from 0 to 320.
    737            * @param Length: line length.
    738            * @param Direction: line direction.
    739            *   This parameter can be one of the following values: LCD_DIR_HORIZONTAL or LCD_DIR_VERTICAL.
    740            * @retval None
    741            */
    742          void LCD_DrawLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length, uint8_t Direction)
    743          {
    744            DMA2D_InitTypeDef      DMA2D_InitStruct;
    745            
    746            uint32_t  Xaddress = 0;
    747            uint16_t Red_Value = 0, Green_Value = 0, Blue_Value = 0;
    748            
    749            Xaddress = CurrentFrameBuffer + 2*(LCD_PIXEL_WIDTH*Ypos + Xpos);
    750           
    751            Red_Value = (0xF800 & CurrentTextColor) >> 11;
    752            Blue_Value = 0x001F & CurrentTextColor;
    753            Green_Value = (0x07E0 & CurrentTextColor) >> 5;
    754          
    755            /* Configure DMA2D */    
    756            DMA2D_DeInit();  
    757            DMA2D_InitStruct.DMA2D_Mode = DMA2D_R2M;       
    758            DMA2D_InitStruct.DMA2D_CMode = DMA2D_RGB565;      
    759            DMA2D_InitStruct.DMA2D_OutputGreen = Green_Value;      
    760            DMA2D_InitStruct.DMA2D_OutputBlue = Blue_Value;     
    761            DMA2D_InitStruct.DMA2D_OutputRed = Red_Value;                
    762            DMA2D_InitStruct.DMA2D_OutputAlpha = 0x0F;                  
    763            DMA2D_InitStruct.DMA2D_OutputMemoryAdd = Xaddress;                  
    764            
    765            if(Direction == LCD_DIR_HORIZONTAL)
    766            {                                                      
    767              DMA2D_InitStruct.DMA2D_OutputOffset = 0;                
    768              DMA2D_InitStruct.DMA2D_NumberOfLine = 1;            
    769              DMA2D_InitStruct.DMA2D_PixelPerLine = Length; 
    770            }
    771            else
    772            {                                                            
    773              DMA2D_InitStruct.DMA2D_OutputOffset = LCD_PIXEL_WIDTH - 1;                
    774              DMA2D_InitStruct.DMA2D_NumberOfLine = Length;            
    775              DMA2D_InitStruct.DMA2D_PixelPerLine = 1;  
    776            }
    777            
    778            DMA2D_Init(&DMA2D_InitStruct);  
    779            /* Start Transfer */ 
    780            DMA2D_StartTransfer();  
    781            /* Wait for CTC Flag activation */
    782            while(DMA2D_GetFlagStatus(DMA2D_FLAG_TC) == RESET)
    783            {
    784            }
    785            
    786          }
    787          
    788          /**
    789            * @brief  Displays a rectangle.
    790            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
    791            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
    792            * @param  Height: display rectangle height, can be a value from 0 to 320.
    793            * @param  Width: display rectangle width, can be a value from 0 to 240.
    794            * @retval None
    795            */
    796          void LCD_DrawRect(uint16_t Xpos, uint16_t Ypos, uint16_t Height, uint16_t Width)
    797          {
    798            /* draw horizontal lines */
    799            LCD_DrawLine(Xpos, Ypos, Width, LCD_DIR_HORIZONTAL);
    800            LCD_DrawLine(Xpos, (Ypos+ Height), Width, LCD_DIR_HORIZONTAL);
    801            
    802            /* draw vertical lines */
    803            LCD_DrawLine(Xpos, Ypos, Height, LCD_DIR_VERTICAL);
    804            LCD_DrawLine((Xpos + Width), Ypos, Height, LCD_DIR_VERTICAL);
    805          }
    806          
    807          /**
    808            * @brief  Draw a circle.
    809            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
    810            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
    811            * @param  Radius: radius of the circle.
    812            * @retval None
    813            */
    814          void LCD_DrawCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)
    815          {
    816              int x = -Radius, y = 0, err = 2-2*Radius, e2;
    817              do {
    818                  *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-x) + LCD_PIXEL_WIDTH*(Ypos+y)))) = CurrentTextColor; 
    819                  *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+x) + LCD_PIXEL_WIDTH*(Ypos+y)))) = CurrentTextColor;
    820                  *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+x) + LCD_PIXEL_WIDTH*(Ypos-y)))) = CurrentTextColor;
    821                  *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-x) + LCD_PIXEL_WIDTH*(Ypos-y)))) = CurrentTextColor;
    822                
    823                  e2 = err;
    824                  if (e2 <= y) {
    825                      err += ++y*2+1;
    826                      if (-x == y && e2 <= x) e2 = 0;
    827                  }
    828                  if (e2 > x) err += ++x*2+1;
    829              }
    830              while (x <= 0);
    831          }
    832          
    833          /**
    834            * @brief  Draw a full ellipse.
    835            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
    836            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
    837            * @param  Radius: minor radius of ellipse.
    838            * @param  Radius2: major radius of ellipse.  
    839            * @retval None
    840            */
    841          void LCD_DrawFullEllipse(int Xpos, int Ypos, int Radius, int Radius2)
    842          {
    843            int x = -Radius, y = 0, err = 2-2*Radius, e2;
    844            float K = 0, rad1 = 0, rad2 = 0;
    845            
    846            rad1 = Radius;
    847            rad2 = Radius2;
    848            
    849            if (Radius > Radius2)
    850            { 
    851              do 
    852              {
    853                K = (float)(rad1/rad2);
    854                LCD_DrawLine((Xpos+x), (Ypos-(uint16_t)(y/K)), (2*(uint16_t)(y/K) + 1), LCD_DIR_VERTICAL);
    855                LCD_DrawLine((Xpos-x), (Ypos-(uint16_t)(y/K)), (2*(uint16_t)(y/K) + 1), LCD_DIR_VERTICAL);
    856                
    857                e2 = err;
    858                if (e2 <= y) 
    859                {
    860                  err += ++y*2+1;
    861                  if (-x == y && e2 <= x) e2 = 0;
    862                }
    863                if (e2 > x) err += ++x*2+1;
    864                
    865              }
    866              while (x <= 0);
    867            }
    868            else
    869            {
    870              y = -Radius2; 
    871              x = 0;
    872              do 
    873              { 
    874                K = (float)(rad2/rad1);       
    875                LCD_DrawLine((Xpos-(uint16_t)(x/K)), (Ypos+y), (2*(uint16_t)(x/K) + 1), LCD_DIR_HORIZONTAL);
    876                LCD_DrawLine((Xpos-(uint16_t)(x/K)), (Ypos-y), (2*(uint16_t)(x/K) + 1), LCD_DIR_HORIZONTAL);
    877                
    878                e2 = err;
    879                if (e2 <= x) 
    880                {
    881                  err += ++x*2+1;
    882                  if (-y == x && e2 <= y) e2 = 0;
    883                }
    884                if (e2 > y) err += ++y*2+1;
    885              }
    886              while (y <= 0);
    887            }
    888          }
    889          
    890          /**
    891            * @brief  Displays an Ellipse.
    892            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
    893            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
    894            * @param  Radius: specifies Radius.
    895            * @param  Radius2: specifies Radius2.
    896            * @retval None
    897            */
    898          void LCD_DrawEllipse(int Xpos, int Ypos, int Radius, int Radius2)
    899          {
    900            int x = -Radius, y = 0, err = 2-2*Radius, e2;
    901            float K = 0, rad1 = 0, rad2 = 0;
    902             
    903            rad1 = Radius;
    904            rad2 = Radius2;
    905            
    906            if (Radius > Radius2)
    907            { 
    908              do {
    909                K = (float)(rad1/rad2);
    910                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-x) + LCD_PIXEL_WIDTH*(Ypos+(uint16_t)(y/K))))) = CurrentTextColor; 
    911                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+x) + LCD_PIXEL_WIDTH*(Ypos+(uint16_t)(y/K))))) = CurrentTextColor;
    912                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+x) + LCD_PIXEL_WIDTH*(Ypos-(uint16_t)(y/K))))) = CurrentTextColor;
    913                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-x) + LCD_PIXEL_WIDTH*(Ypos-(uint16_t)(y/K))))) = CurrentTextColor;
    914                      
    915                e2 = err;
    916                if (e2 <= y) {
    917                  err += ++y*2+1;
    918                  if (-x == y && e2 <= x) e2 = 0;
    919                }
    920                if (e2 > x) err += ++x*2+1;
    921              }
    922              while (x <= 0);
    923            }
    924            else
    925            {
    926              y = -Radius2; 
    927              x = 0;
    928              do { 
    929                K = (float)(rad2/rad1);
    930                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-(uint16_t)(x/K)) + LCD_PIXEL_WIDTH*(Ypos+y)))) = CurrentTextColor; 
    931                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+(uint16_t)(x/K)) + LCD_PIXEL_WIDTH*(Ypos+y)))) = CurrentTextColor;
    932                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos+(uint16_t)(x/K)) + LCD_PIXEL_WIDTH*(Ypos-y)))) = CurrentTextColor;
    933                *(__IO uint16_t*) (CurrentFrameBuffer + (2*((Xpos-(uint16_t)(x/K)) + LCD_PIXEL_WIDTH*(Ypos-y)))) = CurrentTextColor;
    934                
    935                e2 = err;
    936                if (e2 <= x) {
    937                  err += ++x*2+1;
    938                  if (-y == x && e2 <= y) e2 = 0;
    939                }
    940                if (e2 > y) err += ++y*2+1;     
    941              }
    942              while (y <= 0);
    943            }
    944          }
    945          
    946          /**
    947            * @brief  Displays a mono-color picture.
    948            * @param  Pict: pointer to the picture array.
    949            * @retval None
    950            */
    951          void LCD_DrawMonoPict(const uint32_t *Pict)
    952          {
    953            uint32_t index = 0, counter = 0;
    954            
    955             
    956            for(index = 0; index < 2400; index++)
    957            {
    958              for(counter = 0; counter < 32; counter++)
    959              {
    960                if((Pict[index] & (1 << counter)) == 0x00)
    961                {
    962                  *(__IO uint16_t*)(CurrentFrameBuffer) = CurrentBackColor;
    963                }
    964                else
    965                {
    966                  *(__IO uint16_t*)(CurrentFrameBuffer) = CurrentTextColor;
    967                }
    968              }
    969            }
    970          }
    971          
    972          /**
    973            * @brief  Displays a bitmap picture loaded in the internal Flash.
    974            * @param  BmpAddress: Bmp picture address in the internal Flash.
    975            * @retval None
    976            */
    977          void LCD_WriteBMP(uint32_t BmpAddress)
    978          {
    979            uint32_t index = 0, size = 0, width = 0, height = 0, bit_pixel = 0;
    980            uint32_t Address;
    981            uint32_t currentline = 0, linenumber = 0;
    982           
    983            Address = CurrentFrameBuffer;
    984          
    985            /* Read bitmap size */
    986            size = *(__IO uint16_t *) (BmpAddress + 2);
    987            size |= (*(__IO uint16_t *) (BmpAddress + 4)) << 16;
    988            
    989            /* Get bitmap data address offset */
    990            index = *(__IO uint16_t *) (BmpAddress + 10);
    991            index |= (*(__IO uint16_t *) (BmpAddress + 12)) << 16;
    992          
    993            /* Read bitmap width */
    994            width = *(uint16_t *) (BmpAddress + 18);
    995            width |= (*(uint16_t *) (BmpAddress + 20)) << 16;
    996          
    997            /* Read bitmap height */
    998            height = *(uint16_t *) (BmpAddress + 22);
    999            height |= (*(uint16_t *) (BmpAddress + 24)) << 16;
   1000          
   1001            /* Read bit/pixel */
   1002            bit_pixel = *(uint16_t *) (BmpAddress + 28);  
   1003           
   1004            if (CurrentLayer == LCD_BACKGROUND_LAYER)
   1005            {
   1006              /* reconfigure layer size in accordance with the picture */
   1007              LTDC_LayerSize(LTDC_Layer1, width, height);
   1008              LTDC_ReloadConfig(LTDC_VBReload);
   1009          
   1010              /* Reconfigure the Layer pixel format in accordance with the picture */    
   1011              if ((bit_pixel/8) == 4)
   1012              {
   1013                LTDC_LayerPixelFormat(LTDC_Layer1, LTDC_Pixelformat_ARGB8888);
   1014                LTDC_ReloadConfig(LTDC_VBReload);
   1015              }
   1016              else if ((bit_pixel/8) == 2)
   1017              {
   1018                LTDC_LayerPixelFormat(LTDC_Layer1, LTDC_Pixelformat_RGB565);
   1019                LTDC_ReloadConfig(LTDC_VBReload);
   1020              }
   1021              else 
   1022              {
   1023                LTDC_LayerPixelFormat(LTDC_Layer1, LTDC_Pixelformat_RGB888);
   1024                LTDC_ReloadConfig(LTDC_VBReload);
   1025              } 
   1026            }
   1027            else
   1028            {
   1029              /* reconfigure layer size in accordance with the picture */
   1030              LTDC_LayerSize(LTDC_Layer2, width, height);
   1031              LTDC_ReloadConfig(LTDC_VBReload); 
   1032              
   1033              /* Reconfigure the Layer pixel format in accordance with the picture */
   1034              if ((bit_pixel/8) == 4)
   1035              {
   1036                LTDC_LayerPixelFormat(LTDC_Layer2, LTDC_Pixelformat_ARGB8888);
   1037                LTDC_ReloadConfig(LTDC_VBReload);
   1038              }
   1039              else if ((bit_pixel/8) == 2)
   1040              {
   1041                LTDC_LayerPixelFormat(LTDC_Layer2, LTDC_Pixelformat_RGB565);
   1042                LTDC_ReloadConfig(LTDC_VBReload);
   1043              }
   1044              else
   1045              {
   1046                LTDC_LayerPixelFormat(LTDC_Layer2, LTDC_Pixelformat_RGB888);
   1047                LTDC_ReloadConfig(LTDC_VBReload);  
   1048              }
   1049            }
   1050           
   1051            /* compute the real size of the picture (without the header)) */  
   1052            size = (size - index); 
   1053          
   1054            /* bypass the bitmap header */
   1055            BmpAddress += index;
   1056          
   1057            /* start copie image from the bottom */
   1058            Address += width*(height-1)*(bit_pixel/8);
   1059            
   1060            for(index = 0; index < size; index++)
   1061            {
   1062              *(__IO uint8_t*) (Address) = *(__IO uint8_t *)BmpAddress;
   1063              
   1064              /*jump on next byte */   
   1065              BmpAddress++;
   1066              Address++;
   1067              currentline++;
   1068              
   1069              if((currentline/(bit_pixel/8)) == width)
   1070              {
   1071                if(linenumber < height)
   1072                {
   1073                  linenumber++;
   1074                  Address -=(2*width*(bit_pixel/8));
   1075                  currentline = 0;
   1076                }
   1077              }
   1078            }
   1079          }
   1080          
   1081          /**
   1082            * @brief  Displays a full rectangle.
   1083            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
   1084            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
   1085            * @param  Height: rectangle height.
   1086            * @param  Width: rectangle width.
   1087            * @retval None
   1088            */
   1089          void LCD_DrawFullRect(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)
   1090          {
   1091            DMA2D_InitTypeDef      DMA2D_InitStruct;
   1092            
   1093            uint32_t  Xaddress = 0; 
   1094            uint16_t Red_Value = 0, Green_Value = 0, Blue_Value = 0;
   1095           
   1096            Red_Value = (0xF800 & CurrentTextColor) >> 11;
   1097            Blue_Value = 0x001F & CurrentTextColor;
   1098            Green_Value = (0x07E0 & CurrentTextColor) >> 5;
   1099            
   1100            Xaddress = CurrentFrameBuffer + 2*(LCD_PIXEL_WIDTH*Ypos + Xpos);
   1101            
   1102            /* configure DMA2D */
   1103            DMA2D_DeInit();
   1104            DMA2D_InitStruct.DMA2D_Mode = DMA2D_R2M;       
   1105            DMA2D_InitStruct.DMA2D_CMode = DMA2D_RGB565;      
   1106            DMA2D_InitStruct.DMA2D_OutputGreen = Green_Value;      
   1107            DMA2D_InitStruct.DMA2D_OutputBlue = Blue_Value;     
   1108            DMA2D_InitStruct.DMA2D_OutputRed = Red_Value;                
   1109            DMA2D_InitStruct.DMA2D_OutputAlpha = 0x0F;                  
   1110            DMA2D_InitStruct.DMA2D_OutputMemoryAdd = Xaddress;                
   1111            DMA2D_InitStruct.DMA2D_OutputOffset = (LCD_PIXEL_WIDTH - Width);                
   1112            DMA2D_InitStruct.DMA2D_NumberOfLine = Height;            
   1113            DMA2D_InitStruct.DMA2D_PixelPerLine = Width;
   1114            DMA2D_Init(&DMA2D_InitStruct); 
   1115            
   1116            /* Start Transfer */ 
   1117            DMA2D_StartTransfer();
   1118            
   1119            /* Wait for CTC Flag activation */
   1120            while(DMA2D_GetFlagStatus(DMA2D_FLAG_TC) == RESET)
   1121            {
   1122            } 
   1123          
   1124            LCD_SetTextColor(CurrentTextColor);
   1125          }
   1126          
   1127          /**
   1128            * @brief  Displays a full circle.
   1129            * @param  Xpos: specifies the X position, can be a value from 0 to 240.
   1130            * @param  Ypos: specifies the Y position, can be a value from 0 to 320.
   1131            * @param  Radius
   1132            * @retval None
   1133            */
   1134          void LCD_DrawFullCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)
   1135          {
   1136            int32_t  D;    /* Decision Variable */ 
   1137            uint32_t  CurX;/* Current X Value */
   1138            uint32_t  CurY;/* Current Y Value */ 
   1139            
   1140            D = 3 - (Radius << 1);
   1141            
   1142            CurX = 0;
   1143            CurY = Radius;
   1144            
   1145            while (CurX <= CurY)
   1146            {
   1147              if(CurY > 0) 
   1148              {
   1149                LCD_DrawLine(Xpos - CurX, Ypos - CurY, 2*CurY, LCD_DIR_VERTICAL);
   1150                LCD_DrawLine(Xpos + CurX, Ypos - CurY, 2*CurY, LCD_DIR_VERTICAL);
   1151              }
   1152              
   1153              if(CurX > 0) 
   1154              {
   1155                LCD_DrawLine(Xpos - CurY, Ypos - CurX, 2*CurX, LCD_DIR_VERTICAL);
   1156                LCD_DrawLine(Xpos + CurY, Ypos - CurX, 2*CurX, LCD_DIR_VERTICAL);
   1157              }
   1158              if (D < 0)
   1159              { 
   1160                D += (CurX << 2) + 6;
   1161              }
   1162              else
   1163              {
   1164                D += ((CurX - CurY) << 2) + 10;
   1165                CurY--;
   1166              }
   1167              CurX++;
   1168            }
   1169            
   1170            LCD_DrawCircle(Xpos, Ypos, Radius);  
   1171          }
   1172          
   1173          /**
   1174            * @brief  Displays an uni-line (between two points).
   1175            * @param  x1: specifies the point 1 x position.
   1176            * @param  y1: specifies the point 1 y position.
   1177            * @param  x2: specifies the point 2 x position.
   1178            * @param  y2: specifies the point 2 y position.
   1179            * @retval None
   1180            */
   1181          void LCD_DrawUniLine(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)
   1182          {
   1183            int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0, 
   1184            yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0, 
   1185            curpixel = 0;
   1186            
   1187            deltax = ABS(x2 - x1);        /* The difference between the x's */
   1188            deltay = ABS(y2 - y1);        /* The difference between the y's */
   1189            x = x1;                       /* Start x off at the first pixel */
   1190            y = y1;                       /* Start y off at the first pixel */
   1191            
   1192            if (x2 >= x1)                 /* The x-values are increasing */
   1193            {
   1194              xinc1 = 1;
   1195              xinc2 = 1;
   1196            }
   1197            else                          /* The x-values are decreasing */
   1198            {
   1199              xinc1 = -1;
   1200              xinc2 = -1;
   1201            }
   1202            
   1203            if (y2 >= y1)                 /* The y-values are increasing */
   1204            {
   1205              yinc1 = 1;
   1206              yinc2 = 1;
   1207            }
   1208            else                          /* The y-values are decreasing */
   1209            {
   1210              yinc1 = -1;
   1211              yinc2 = -1;
   1212            }
   1213            
   1214            if (deltax >= deltay)         /* There is at least one x-value for every y-value */
   1215            {
   1216              xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
   1217              yinc2 = 0;                  /* Don't change the y for every iteration */
   1218              den = deltax;
   1219              num = deltax / 2;
   1220              numadd = deltay;
   1221              numpixels = deltax;         /* There are more x-values than y-values */
   1222            }
   1223            else                          /* There is at least one y-value for every x-value */
   1224            {
   1225              xinc2 = 0;                  /* Don't change the x for every iteration */
   1226              yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
   1227              den = deltay;
   1228              num = deltay / 2;
   1229              numadd = deltax;
   1230              numpixels = deltay;         /* There are more y-values than x-values */
   1231            }
   1232            
   1233            for (curpixel = 0; curpixel <= numpixels; curpixel++)
   1234            {
   1235              PutPixel(x, y);             /* Draw the current pixel */
   1236              num += numadd;              /* Increase the numerator by the top of the fraction */
   1237              if (num >= den)             /* Check if numerator >= denominator */
   1238              {
   1239                num -= den;               /* Calculate the new numerator value */
   1240                x += xinc1;               /* Change the x as appropriate */
   1241                y += yinc1;               /* Change the y as appropriate */
   1242              }
   1243              x += xinc2;                 /* Change the x as appropriate */
   1244              y += yinc2;                 /* Change the y as appropriate */
   1245            }
   1246          }
   1247          
   1248          /**
   1249            * @brief  Displays an triangle.
   1250            * @param  Points: pointer to the points array.
   1251            * @retval None
   1252            */
   1253          void LCD_Triangle(pPoint Points, uint16_t PointCount)
   1254          {
   1255            int16_t X = 0, Y = 0;
   1256            pPoint First = Points;
   1257          
   1258            if(PointCount != 3)
   1259            {
   1260              return;
   1261            }
   1262          
   1263            while(--PointCount)
   1264            {
   1265              X = Points->X;
   1266              Y = Points->Y;
   1267              Points++;
   1268              LCD_DrawUniLine(X, Y, Points->X, Points->Y);
   1269            }
   1270            LCD_DrawUniLine(First->X, First->Y, Points->X, Points->Y);
   1271          }
   1272          
   1273          /**
   1274            * @brief  Fill an triangle (between 3 points).
   1275            * @param  x1..3: x position of triangle point 1..3.
   1276            * @param  y1..3: y position of triangle point 1..3.
   1277            * @retval None
   1278            */
   1279          void LCD_FillTriangle(uint16_t x1, uint16_t x2, uint16_t x3, uint16_t y1, uint16_t y2, uint16_t y3)
   1280          { 
   1281            
   1282            int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0, 
   1283            yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0, 
   1284            curpixel = 0;
   1285            
   1286            deltax = ABS(x2 - x1);        /* The difference between the x's */
   1287            deltay = ABS(y2 - y1);        /* The difference between the y's */
   1288            x = x1;                       /* Start x off at the first pixel */
   1289            y = y1;                       /* Start y off at the first pixel */
   1290            
   1291            if (x2 >= x1)                 /* The x-values are increasing */
   1292            {
   1293              xinc1 = 1;
   1294              xinc2 = 1;
   1295            }
   1296            else                          /* The x-values are decreasing */
   1297            {
   1298              xinc1 = -1;
   1299              xinc2 = -1;
   1300            }
   1301            
   1302            if (y2 >= y1)                 /* The y-values are increasing */
   1303            {
   1304              yinc1 = 1;
   1305              yinc2 = 1;
   1306            }
   1307            else                          /* The y-values are decreasing */
   1308            {
   1309              yinc1 = -1;
   1310              yinc2 = -1;
   1311            }
   1312            
   1313            if (deltax >= deltay)         /* There is at least one x-value for every y-value */
   1314            {
   1315              xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
   1316              yinc2 = 0;                  /* Don't change the y for every iteration */
   1317              den = deltax;
   1318              num = deltax / 2;
   1319              numadd = deltay;
   1320              numpixels = deltax;         /* There are more x-values than y-values */
   1321            }
   1322            else                          /* There is at least one y-value for every x-value */
   1323            {
   1324              xinc2 = 0;                  /* Don't change the x for every iteration */
   1325              yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
   1326              den = deltay;
   1327              num = deltay / 2;
   1328              numadd = deltax;
   1329              numpixels = deltay;         /* There are more y-values than x-values */
   1330            }
   1331            
   1332            for (curpixel = 0; curpixel <= numpixels; curpixel++)
   1333            {
   1334              LCD_DrawUniLine(x, y, x3, y3);
   1335              
   1336              num += numadd;              /* Increase the numerator by the top of the fraction */
   1337              if (num >= den)             /* Check if numerator >= denominator */
   1338              {
   1339                num -= den;               /* Calculate the new numerator value */
   1340                x += xinc1;               /* Change the x as appropriate */
   1341                y += yinc1;               /* Change the y as appropriate */
   1342              }
   1343              x += xinc2;                 /* Change the x as appropriate */
   1344              y += yinc2;                 /* Change the y as appropriate */
   1345            }  
   1346            
   1347            
   1348          }
   1349          /**
   1350            * @brief  Displays an poly-line (between many points).
   1351            * @param  Points: pointer to the points array.
   1352            * @param  PointCount: Number of points.
   1353            * @retval None
   1354            */
   1355          void LCD_PolyLine(pPoint Points, uint16_t PointCount)
   1356          {
   1357            int16_t X = 0, Y = 0;
   1358          
   1359            if(PointCount < 2)
   1360            {
   1361              return;
   1362            }
   1363          
   1364            while(--PointCount)
   1365            {
   1366              X = Points->X;
   1367              Y = Points->Y;
   1368              Points++;
   1369              LCD_DrawUniLine(X, Y, Points->X, Points->Y);
   1370            }
   1371          }
   1372          
   1373          /**
   1374            * @brief  Displays an relative poly-line (between many points).
   1375            * @param  Points: pointer to the points array.
   1376            * @param  PointCount: Number of points.
   1377            * @param  Closed: specifies if the draw is closed or not.
   1378            *           1: closed, 0 : not closed.
   1379            * @retval None
   1380            */
   1381          static void LCD_PolyLineRelativeClosed(pPoint Points, uint16_t PointCount, uint16_t Closed)
   1382          {
   1383            int16_t X = 0, Y = 0;
   1384            pPoint First = Points;
   1385          
   1386            if(PointCount < 2)
   1387            {
   1388              return;
   1389            }  
   1390            X = Points->X;
   1391            Y = Points->Y;
   1392            while(--PointCount)
   1393            {
   1394              Points++;
   1395              LCD_DrawUniLine(X, Y, X + Points->X, Y + Points->Y);
   1396              X = X + Points->X;
   1397              Y = Y + Points->Y;
   1398            }
   1399            if(Closed)
   1400            {
   1401              LCD_DrawUniLine(First->X, First->Y, X, Y);
   1402            }  
   1403          }
   1404          
   1405          /**
   1406            * @brief  Displays a closed poly-line (between many points).
   1407            * @param  Points: pointer to the points array.
   1408            * @param  PointCount: Number of points.
   1409            * @retval None
   1410            */
   1411          void LCD_ClosedPolyLine(pPoint Points, uint16_t PointCount)
   1412          {
   1413            LCD_PolyLine(Points, PointCount);
   1414            LCD_DrawUniLine(Points->X, Points->Y, (Points+PointCount-1)->X, (Points+PointCount-1)->Y);
   1415          }
   1416          
   1417          /**
   1418            * @brief  Displays a relative poly-line (between many points).
   1419            * @param  Points: pointer to the points array.
   1420            * @param  PointCount: Number of points.
   1421            * @retval None
   1422            */
   1423          void LCD_PolyLineRelative(pPoint Points, uint16_t PointCount)
   1424          {
   1425            LCD_PolyLineRelativeClosed(Points, PointCount, 0);
   1426          }
   1427          
   1428          /**
   1429            * @brief  Displays a closed relative poly-line (between many points).
   1430            * @param  Points: pointer to the points array.
   1431            * @param  PointCount: Number of points.
   1432            * @retval None
   1433            */
   1434          void LCD_ClosedPolyLineRelative(pPoint Points, uint16_t PointCount)
   1435          {
   1436            LCD_PolyLineRelativeClosed(Points, PointCount, 1);
   1437          }
   1438          
   1439          /**
   1440            * @brief  Displays a  full poly-line (between many points).
   1441            * @param  Points: pointer to the points array.
   1442            * @param  PointCount: Number of points.
   1443            * @retval None
   1444            */
   1445          void LCD_FillPolyLine(pPoint Points, uint16_t PointCount)
   1446          {
   1447           
   1448            int16_t X = 0, Y = 0, X2 = 0, Y2 = 0, X_center = 0, Y_center = 0, X_first = 0, Y_first = 0, pixelX = 0, pixelY = 0, counter = 0;
   1449            uint16_t  IMAGE_LEFT = 0, IMAGE_RIGHT = 0, IMAGE_TOP = 0, IMAGE_BOTTOM = 0;  
   1450          
   1451            IMAGE_LEFT = IMAGE_RIGHT = Points->X;
   1452            IMAGE_TOP= IMAGE_BOTTOM = Points->Y;
   1453          
   1454            for(counter = 1; counter < PointCount; counter++)
   1455            {
   1456              pixelX = POLY_X(counter);
   1457              if(pixelX < IMAGE_LEFT)
   1458              {
   1459                IMAGE_LEFT = pixelX;
   1460              }
   1461              if(pixelX > IMAGE_RIGHT)
   1462              {
   1463                IMAGE_RIGHT = pixelX;
   1464              }
   1465              
   1466              pixelY = POLY_Y(counter);
   1467              if(pixelY < IMAGE_TOP)
   1468              { 
   1469                IMAGE_TOP = pixelY;
   1470              }
   1471              if(pixelY > IMAGE_BOTTOM)
   1472              {
   1473                IMAGE_BOTTOM = pixelY;
   1474              }
   1475            }  
   1476            
   1477            if(PointCount < 2)
   1478            {
   1479              return;
   1480            }
   1481            
   1482            X_center = (IMAGE_LEFT + IMAGE_RIGHT)/2;
   1483            Y_center = (IMAGE_BOTTOM + IMAGE_TOP)/2;
   1484           
   1485            X_first = Points->X;
   1486            Y_first = Points->Y;
   1487            
   1488            while(--PointCount)
   1489            {
   1490              X = Points->X;
   1491              Y = Points->Y;
   1492              Points++;
   1493              X2 = Points->X;
   1494              Y2 = Points->Y;    
   1495            
   1496              LCD_FillTriangle(X, X2, X_center, Y, Y2, Y_center);
   1497              LCD_FillTriangle(X, X_center, X2, Y, Y_center, Y2);
   1498              LCD_FillTriangle(X_center, X2, X, Y_center, Y2, Y);   
   1499            }
   1500            
   1501            LCD_FillTriangle(X_first, X2, X_center, Y_first, Y2, Y_center);
   1502            LCD_FillTriangle(X_first, X_center, X2, Y_first, Y_center, Y2);
   1503            LCD_FillTriangle(X_center, X2, X_first, Y_center, Y2, Y_first); 
   1504          }
   1505          
   1506          /**
   1507            * @brief  Writes command to select the LCD register.
   1508            * @param  LCD_Reg: address of the selected register.
   1509            * @retval None
   1510            */
   1511          void LCD_WriteCommand(uint8_t LCD_Reg)
   1512          {
   1513              /* Reset WRX to send command */
   1514            LCD_CtrlLinesWrite(LCD_WRX_GPIO_PORT, LCD_WRX_PIN, Bit_RESET);
   1515            
   1516            /* Reset LCD control line(/CS) and Send command */
   1517            LCD_ChipSelect(DISABLE);
   1518            SPI_I2S_SendData(LCD_SPI, LCD_Reg);
   1519            
   1520            /* Wait until a data is sent(not busy), before config /CS HIGH */
   1521            
   1522            while(SPI_I2S_GetFlagStatus(LCD_SPI, SPI_I2S_FLAG_TXE) == RESET) ;
   1523            
   1524            while(SPI_I2S_GetFlagStatus(LCD_SPI, SPI_I2S_FLAG_BSY) != RESET);
   1525            
   1526            LCD_ChipSelect(ENABLE);
   1527          }
   1528          
   1529          /**
   1530            * @brief  Writes data to select the LCD register.
   1531            *         This function must be used after LCD_WriteCommand() function
   1532            * @param  value: data to write to the selected register.
   1533            * @retval None
   1534            */
   1535          void LCD_WriteData(uint8_t value)
   1536          {
   1537              /* Set WRX to send data */
   1538            LCD_CtrlLinesWrite(LCD_WRX_GPIO_PORT, LCD_WRX_PIN, Bit_SET);
   1539            
   1540            /* Reset LCD control line(/CS) and Send data */  
   1541            LCD_ChipSelect(DISABLE);
   1542            SPI_I2S_SendData(LCD_SPI, value);
   1543            
   1544            /* Wait until a data is sent(not busy), before config /CS HIGH */
   1545            
   1546            while(SPI_I2S_GetFlagStatus(LCD_SPI, SPI_I2S_FLAG_TXE) == RESET) ;
   1547            
   1548            while(SPI_I2S_GetFlagStatus(LCD_SPI, SPI_I2S_FLAG_BSY) != RESET);
   1549            
   1550            LCD_ChipSelect(ENABLE);
   1551          }
   1552          
   1553          /**
   1554            * @brief  Configure the LCD controller (Power On sequence as described in ILI9341 Datasheet)
   1555            * @param  None
   1556            * @retval None
   1557            */
   1558          void LCD_PowerOn(void)
   1559          {
   1560            LCD_WriteCommand(0xCA);
   1561            LCD_WriteData(0xC3);
   1562            LCD_WriteData(0x08);
   1563            LCD_WriteData(0x50);
   1564            LCD_WriteCommand(LCD_POWERB);
   1565            LCD_WriteData(0x00);
   1566            LCD_WriteData(0xC1);
   1567            LCD_WriteData(0x30);
   1568            LCD_WriteCommand(LCD_POWER_SEQ);
   1569            LCD_WriteData(0x64);
   1570            LCD_WriteData(0x03);
   1571            LCD_WriteData(0x12);
   1572            LCD_WriteData(0x81);
   1573            LCD_WriteCommand(LCD_DTCA);
   1574            LCD_WriteData(0x85);
   1575            LCD_WriteData(0x00);
   1576            LCD_WriteData(0x78);
   1577            LCD_WriteCommand(LCD_POWERA);
   1578            LCD_WriteData(0x39);
   1579            LCD_WriteData(0x2C);
   1580            LCD_WriteData(0x00);
   1581            LCD_WriteData(0x34);
   1582            LCD_WriteData(0x02);
   1583            LCD_WriteCommand(LCD_PRC);
   1584            LCD_WriteData(0x20);
   1585            LCD_WriteCommand(LCD_DTCB);
   1586            LCD_WriteData(0x00);
   1587            LCD_WriteData(0x00);
   1588            LCD_WriteCommand(LCD_FRC);
   1589            LCD_WriteData(0x00);
   1590            LCD_WriteData(0x1B);
   1591            LCD_WriteCommand(LCD_DFC);
   1592            LCD_WriteData(0x0A);
   1593            LCD_WriteData(0xA2);
   1594            LCD_WriteCommand(LCD_POWER1);
   1595            LCD_WriteData(0x10);
   1596            LCD_WriteCommand(LCD_POWER2);
   1597            LCD_WriteData(0x10);
   1598            LCD_WriteCommand(LCD_VCOM1);
   1599            LCD_WriteData(0x45);
   1600            LCD_WriteData(0x15);
   1601            LCD_WriteCommand(LCD_VCOM2);
   1602            LCD_WriteData(0x90);
   1603            LCD_WriteCommand(LCD_MAC);
   1604            LCD_WriteData(0xA8);
   1605            LCD_WriteCommand(LCD_3GAMMA_EN);
   1606            LCD_WriteData(0x00);
   1607            LCD_WriteCommand(LCD_RGB_INTERFACE);
   1608            LCD_WriteData(0xC2);
   1609            LCD_WriteCommand(LCD_DFC);
   1610            LCD_WriteData(0x0A);
   1611            LCD_WriteData(0xA7);
   1612            LCD_WriteData(0x27);
   1613            LCD_WriteData(0x04);
   1614          
   1615            /* colomn address set */
   1616            LCD_WriteCommand(LCD_COLUMN_ADDR);
   1617            LCD_WriteData(0x00);
   1618            LCD_WriteData(0x00);
   1619            LCD_WriteData(0x00);
   1620            LCD_WriteData(0xEF);
   1621            /* Page Address Set */
   1622            LCD_WriteCommand(LCD_PAGE_ADDR);
   1623            LCD_WriteData(0x00);
   1624            LCD_WriteData(0x00);
   1625            LCD_WriteData(0x01);
   1626            LCD_WriteData(0x3F);
   1627            LCD_WriteCommand(LCD_INTERFACE);
   1628            LCD_WriteData(0x01);
   1629            LCD_WriteData(0x00);
   1630            LCD_WriteData(0x06);
   1631            
   1632            LCD_WriteCommand(LCD_GRAM);
   1633            delay(200);
   1634            
   1635            LCD_WriteCommand(LCD_GAMMA);
   1636            LCD_WriteData(0x01);
   1637            
   1638            LCD_WriteCommand(LCD_PGAMMA);
   1639            LCD_WriteData(0x0F);
   1640            LCD_WriteData(0x29);
   1641            LCD_WriteData(0x24);
   1642            LCD_WriteData(0x0C);
   1643            LCD_WriteData(0x0E);
   1644            LCD_WriteData(0x09);
   1645            LCD_WriteData(0x4E);
   1646            LCD_WriteData(0x78);
   1647            LCD_WriteData(0x3C);
   1648            LCD_WriteData(0x09);
   1649            LCD_WriteData(0x13);
   1650            LCD_WriteData(0x05);
   1651            LCD_WriteData(0x17);
   1652            LCD_WriteData(0x11);
   1653            LCD_WriteData(0x00);
   1654            LCD_WriteCommand(LCD_NGAMMA);
   1655            LCD_WriteData(0x00);
   1656            LCD_WriteData(0x16);
   1657            LCD_WriteData(0x1B);
   1658            LCD_WriteData(0x04);
   1659            LCD_WriteData(0x11);
   1660            LCD_WriteData(0x07);
   1661            LCD_WriteData(0x31);
   1662            LCD_WriteData(0x33);
   1663            LCD_WriteData(0x42);
   1664            LCD_WriteData(0x05);
   1665            LCD_WriteData(0x0C);
   1666            LCD_WriteData(0x0A);
   1667            LCD_WriteData(0x28);
   1668            LCD_WriteData(0x2F);
   1669            LCD_WriteData(0x0F);
   1670            
   1671            LCD_WriteCommand(LCD_SLEEP_OUT);
   1672            delay(200);
   1673            LCD_WriteCommand(LCD_DISPLAY_ON);
   1674            /* GRAM start writing */
   1675            LCD_WriteCommand(LCD_GRAM);
   1676           }
   1677          
   1678          /**
   1679            * @brief  Enables the Display.
   1680            * @param  None
   1681            * @retval None
   1682            */
   1683          void LCD_DisplayOn(void)
   1684          {
   1685            LCD_WriteCommand(LCD_DISPLAY_ON);
   1686          }
   1687          
   1688          /**
   1689            * @brief  Disables the Display.
   1690            * @param  None
   1691            * @retval None
   1692            */
   1693          void LCD_DisplayOff(void)
   1694          {
   1695              /* Display Off */
   1696              LCD_WriteCommand(LCD_DISPLAY_OFF);
   1697          }
   1698          
   1699          /**
   1700            * @brief  Configures LCD control lines in Output Push-Pull mode.
   1701            * @note   The LCD_NCS line can be configured in Open Drain mode  
   1702            *         when VDDIO is lower than required LCD supply.
   1703            * @param  None
   1704            * @retval None
   1705            */
   1706          void LCD_CtrlLinesConfig(void)
   1707          {
   1708            GPIO_InitTypeDef GPIO_InitStructure;
   1709          
   1710            /* Enable GPIOs clock*/
   1711            RCC_AHB1PeriphClockCmd(LCD_NCS_GPIO_CLK | LCD_WRX_GPIO_CLK, ENABLE);
   1712          
   1713            /* Configure NCS in Output Push-Pull mode */
   1714            GPIO_InitStructure.GPIO_Pin = LCD_NCS_PIN;
   1715            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   1716            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   1717            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   1718            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   1719            GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
   1720            
   1721            /* Configure WRX in Output Push-Pull mode */
   1722            GPIO_InitStructure.GPIO_Pin = LCD_WRX_PIN;
   1723            GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
   1724          
   1725            /* Set chip select pin high */
   1726            LCD_CtrlLinesWrite(LCD_NCS_GPIO_PORT, LCD_NCS_PIN, Bit_SET);
   1727          }
   1728          
   1729          /**
   1730            * @brief  Sets or reset LCD control lines.
   1731            * @param  GPIOx: where x can be B or D to select the GPIO peripheral.
   1732            * @param  CtrlPins: the Control line.
   1733            *   This parameter can be:
   1734            *     @arg LCD_NCS_PIN: Chip Select pin
   1735            *     @arg LCD_NWR_PIN: Read/Write Selection pin
   1736            *     @arg LCD_RS_PIN: Register/RAM Selection pin
   1737            * @param  BitVal: specifies the value to be written to the selected bit.
   1738            *   This parameter can be:
   1739            *     @arg Bit_RESET: to clear the port pin
   1740            *     @arg Bit_SET: to set the port pin
   1741            * @retval None
   1742            */
   1743          void LCD_CtrlLinesWrite(GPIO_TypeDef* GPIOx, uint16_t CtrlPins, BitAction BitVal)
   1744          {
   1745            /* Set or Reset the control line */
   1746            GPIO_WriteBit(GPIOx, (uint16_t)CtrlPins, (BitAction)BitVal);
   1747          }
   1748          
   1749          /**
   1750            * @brief  Configures the LCD_SPI interface.
   1751            * @param  None
   1752            * @retval None
   1753            */
   1754          void LCD_SPIConfig(void)
   1755          {
   1756            SPI_InitTypeDef    SPI_InitStructure;
   1757            GPIO_InitTypeDef   GPIO_InitStructure;
   1758          
   1759            /* Enable LCD_SPI_SCK_GPIO_CLK, LCD_SPI_MISO_GPIO_CLK and LCD_SPI_MOSI_GPIO_CLK clock */
   1760            RCC_AHB1PeriphClockCmd(LCD_SPI_SCK_GPIO_CLK | LCD_SPI_MISO_GPIO_CLK | LCD_SPI_MOSI_GPIO_CLK, ENABLE);
   1761          
   1762            /* Enable LCD_SPI and SYSCFG clock  */
   1763            RCC_APB2PeriphClockCmd(LCD_SPI_CLK, ENABLE);
   1764            
   1765            /* Configure LCD_SPI SCK pin */
   1766            GPIO_InitStructure.GPIO_Pin = LCD_SPI_SCK_PIN;
   1767            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
   1768            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   1769            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   1770            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
   1771            GPIO_Init(LCD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
   1772          
   1773            /* Configure LCD_SPI MISO pin */
   1774            GPIO_InitStructure.GPIO_Pin = LCD_SPI_MISO_PIN;
   1775            GPIO_Init(LCD_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
   1776          
   1777            /* Configure LCD_SPI MOSI pin */
   1778            GPIO_InitStructure.GPIO_Pin = LCD_SPI_MOSI_PIN;
   1779            GPIO_Init(LCD_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
   1780          
   1781            /* Connect SPI SCK */
   1782            GPIO_PinAFConfig(LCD_SPI_SCK_GPIO_PORT, LCD_SPI_SCK_SOURCE, LCD_SPI_SCK_AF);
   1783          
   1784            /* Connect SPI MISO */
   1785            GPIO_PinAFConfig(LCD_SPI_MISO_GPIO_PORT, LCD_SPI_MISO_SOURCE, LCD_SPI_MISO_AF);
   1786          
   1787            /* Connect SPI MOSI */
   1788            GPIO_PinAFConfig(LCD_SPI_MOSI_GPIO_PORT, LCD_SPI_MOSI_SOURCE, LCD_SPI_MOSI_AF);
   1789            
   1790            SPI_I2S_DeInit(LCD_SPI);
   1791          
   1792            /* SPI configuration -------------------------------------------------------*/
   1793            /* If the SPI peripheral is already enabled, don't reconfigure it */
   1794            if ((LCD_SPI->CR1 & SPI_CR1_SPE) == 0)
   1795            {    
   1796              SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   1797              SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   1798              SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   1799              SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
   1800              SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
   1801              SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
   1802              /* SPI baudrate is set to 5.6 MHz (PCLK2/SPI_BaudRatePrescaler = 90/16 = 5.625 MHz) 
   1803                 to verify these constraints:
   1804                    - ILI9341 LCD SPI interface max baudrate is 10MHz for write and 6.66MHz for read
   1805                    - l3gd20 SPI interface max baudrate is 10MHz for write/read
   1806                    - PCLK2 frequency is set to 90 MHz 
   1807                 */
   1808              SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
   1809              SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   1810              SPI_InitStructure.SPI_CRCPolynomial = 7;
   1811              SPI_Init(LCD_SPI, &SPI_InitStructure);
   1812          
   1813              /* Enable L3GD20_SPI  */
   1814              SPI_Cmd(LCD_SPI, ENABLE);
   1815            }
   1816          }
   1817          
   1818          /**
   1819            * @brief  GPIO config for LTDC.
   1820            * @param  None
   1821            * @retval None
   1822            */
   1823          static void LCD_AF_GPIOConfig(void)
   1824          {
   1825            GPIO_InitTypeDef GPIO_InitStruct;
   1826            
   1827            /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOF, GPIOG AHB Clocks */
   1828            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | \
   1829                                   RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOD | \
   1830                                   RCC_AHB1Periph_GPIOF | RCC_AHB1Periph_GPIOG, ENABLE);
   1831          
   1832          /* GPIOs Configuration */
   1833          /*
   1834           +------------------------+-----------------------+----------------------------+
   1835           +                       LCD pins assignment                                   +
   1836           +------------------------+-----------------------+----------------------------+
   1837           |  LCD_TFT R2 <-> PC.10  |  LCD_TFT G2 <-> PA.06 |  LCD_TFT B2 <-> PD.06      |
   1838           |  LCD_TFT R3 <-> PB.00  |  LCD_TFT G3 <-> PG.10 |  LCD_TFT B3 <-> PG.11      |
   1839           |  LCD_TFT R4 <-> PA.11  |  LCD_TFT G4 <-> PB.10 |  LCD_TFT B4 <-> PG.12      |
   1840           |  LCD_TFT R5 <-> PA.12  |  LCD_TFT G5 <-> PB.11 |  LCD_TFT B5 <-> PA.03      |
   1841           |  LCD_TFT R6 <-> PB.01  |  LCD_TFT G6 <-> PC.07 |  LCD_TFT B6 <-> PB.08      |
   1842           |  LCD_TFT R7 <-> PG.06  |  LCD_TFT G7 <-> PD.03 |  LCD_TFT B7 <-> PB.09      |
   1843           -------------------------------------------------------------------------------
   1844                    |  LCD_TFT HSYNC <-> PC.06  | LCDTFT VSYNC <->  PA.04 |
   1845                    |  LCD_TFT CLK   <-> PG.07  | LCD_TFT DE   <->  PF.10 |
   1846                     -----------------------------------------------------
   1847          
   1848          */
   1849          
   1850           /* GPIOA configuration */
   1851            GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_LTDC);
   1852            GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_LTDC);
   1853            GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_LTDC);
   1854            GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_LTDC);
   1855            GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_LTDC);
   1856          
   1857            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | \
   1858                                       GPIO_Pin_11 | GPIO_Pin_12;
   1859                                       
   1860            GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
   1861            GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
   1862            GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
   1863            GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
   1864            GPIO_Init(GPIOA, &GPIO_InitStruct);
   1865            
   1866           /* GPIOB configuration */  
   1867            GPIO_PinAFConfig(GPIOB, GPIO_PinSource0, 0x09);
   1868            GPIO_PinAFConfig(GPIOB, GPIO_PinSource1, 0x09);
   1869            GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_LTDC);
   1870            GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_LTDC);
   1871            GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_LTDC);
   1872            GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_LTDC);
   1873          
   1874            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | \
   1875                                       GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
   1876            
   1877            GPIO_Init(GPIOB, &GPIO_InitStruct);
   1878          
   1879           /* GPIOC configuration */
   1880            GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_LTDC);
   1881            GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_LTDC);
   1882            GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_LTDC);
   1883            
   1884            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_10;
   1885                                       
   1886            GPIO_Init(GPIOC, &GPIO_InitStruct);
   1887          
   1888           /* GPIOD configuration */
   1889            GPIO_PinAFConfig(GPIOD, GPIO_PinSource3, GPIO_AF_LTDC);
   1890            GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_LTDC);
   1891            
   1892            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_6;
   1893                                       
   1894            GPIO_Init(GPIOD, &GPIO_InitStruct);
   1895            
   1896           /* GPIOF configuration */
   1897            GPIO_PinAFConfig(GPIOF, GPIO_PinSource10, GPIO_AF_LTDC);
   1898            
   1899            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;
   1900                                       
   1901            GPIO_Init(GPIOF, &GPIO_InitStruct);     
   1902          
   1903           /* GPIOG configuration */  
   1904            GPIO_PinAFConfig(GPIOG, GPIO_PinSource6, GPIO_AF_LTDC);
   1905            GPIO_PinAFConfig(GPIOG, GPIO_PinSource7, GPIO_AF_LTDC);
   1906            GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, 0x09);
   1907            GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_LTDC);
   1908            GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, 0x09);
   1909          
   1910            GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_10 | \
   1911                                       GPIO_Pin_11 | GPIO_Pin_12;
   1912            
   1913            GPIO_Init(GPIOG, &GPIO_InitStruct);
   1914           
   1915          }
   1916          
   1917          /**
   1918            * @brief  Displays a pixel.
   1919            * @param  x: pixel x.
   1920            * @param  y: pixel y.  
   1921            * @retval None
   1922            */
   1923          static void PutPixel(int16_t x, int16_t y)
   1924          { 
   1925            if(x < 0 || x > 239 || y < 0 || y > 319)
   1926            {
   1927              return;  
   1928            }
   1929            LCD_DrawLine(x, y, 1, LCD_DIR_HORIZONTAL);
   1930          }
   1931          
   1932          #ifndef USE_Delay
   1933          /**
   1934            * @brief  Inserts a delay time.
   1935            * @param  nCount: specifies the delay time length.
   1936            * @retval None
   1937            */
   1938          static void delay(__IO uint32_t nCount)
   1939          {
   1940            __IO uint32_t index = 0; 
   1941            for(index = nCount; index != 0; index--)
   1942            {
   1943            }
   1944          }
   1945          #endif /* USE_Delay*/
   1946          /**
   1947            * @}
   1948            */ 
   1949          
   1950          /**
   1951            * @}
   1952            */ 
   1953          
   1954          /**
   1955            * @}
   1956            */ 
   1957          
   1958          /**
   1959            * @}
   1960            */ 
   1961          
   1962          /**
   1963            * @}
   1964            */ 
   1965          
   1966          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LCD_AF_GPIOConfig
        16   -> GPIO_Init
        16   -> GPIO_PinAFConfig
        16   -> RCC_AHB1PeriphClockCmd
       0   LCD_ChipSelect
         0   -> GPIO_ResetBits
         0   -> GPIO_SetBits
       0   LCD_Clear
      16   LCD_ClearLine
        16   -> LCD_DrawChar
      16   LCD_ClosedPolyLine
         0   -> LCD_DrawUniLine
        16   -> LCD_PolyLine
       0   LCD_ClosedPolyLineRelative
         0   -> LCD_PolyLineRelativeClosed
      16   LCD_CtrlLinesConfig
        16   -> GPIO_Init
        16   -> GPIO_WriteBit
        16   -> RCC_AHB1PeriphClockCmd
       0   LCD_CtrlLinesWrite
         0   -> GPIO_WriteBit
      32   LCD_DeInit
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> GPIO_WriteBit
        32   -> RCC_APB2PeriphClockCmd
        32   -> SPI_Cmd
        32   -> SPI_I2S_DeInit
        32   -> SPI_I2S_GetFlagStatus
        32   -> SPI_I2S_SendData
       8   LCD_DisplayChar
         0   -> LCD_DrawChar
      16   LCD_DisplayOff
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> GPIO_WriteBit
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_SendData
      16   LCD_DisplayOn
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> GPIO_WriteBit
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_SendData
      24   LCD_DisplayStringLine
        24   -> LCD_DrawChar
      32   LCD_DrawChar
      24   LCD_DrawCircle
      24   LCD_DrawEllipse
      88   LCD_DrawFullCircle
        88   -> DMA2D_DeInit
        88   -> DMA2D_GetFlagStatus
        88   -> DMA2D_Init
        88   -> DMA2D_StartTransfer
        88   -> LCD_DrawCircle
     120   LCD_DrawFullEllipse
       120   -> DMA2D_DeInit
       120   -> DMA2D_GetFlagStatus
       120   -> DMA2D_Init
       120   -> DMA2D_StartTransfer
      72   LCD_DrawFullRect
        72   -> DMA2D_DeInit
        72   -> DMA2D_GetFlagStatus
        72   -> DMA2D_Init
        72   -> DMA2D_StartTransfer
      72   LCD_DrawLine
        72   -> DMA2D_DeInit
        72   -> DMA2D_GetFlagStatus
        72   -> DMA2D_Init
        72   -> DMA2D_StartTransfer
      12   LCD_DrawMonoPict
      96   LCD_DrawRect
        96   -> DMA2D_DeInit
        96   -> DMA2D_GetFlagStatus
        96   -> DMA2D_Init
        96   -> DMA2D_StartTransfer
     104   LCD_DrawUniLine
       104   -> DMA2D_DeInit
       104   -> DMA2D_GetFlagStatus
       104   -> DMA2D_Init
       104   -> DMA2D_StartTransfer
      56   LCD_FillPolyLine
        56   -> LCD_FillTriangle
      56   LCD_FillTriangle
        56   -> LCD_DrawUniLine
       0   LCD_GetColors
       0   LCD_GetFont
      72   LCD_Init
        72   -> GPIO_ResetBits
        72   -> GPIO_SetBits
        72   -> LCD_AF_GPIOConfig
        72   -> LCD_CtrlLinesConfig
        72   -> LCD_PowerOn
        72   -> LCD_SPIConfig
        72   -> LTDC_Init
        72   -> RCC_AHB1PeriphClockCmd
        72   -> RCC_APB2PeriphClockCmd
        72   -> RCC_GetFlagStatus
        72   -> RCC_LTDCCLKDivConfig
        72   -> RCC_PLLSAICmd
        72   -> RCC_PLLSAIConfig
        72   -> SDRAM_Init
      80   LCD_LayerInit
        80   -> LTDC_DitherCmd
        80   -> LTDC_LayerCmd
        80   -> LTDC_LayerInit
        80   -> LTDC_ReloadConfig
      16   LCD_PolyLine
        16   -> LCD_DrawUniLine
       0   LCD_PolyLineRelative
         0   -> LCD_PolyLineRelativeClosed
      32   LCD_PolyLineRelativeClosed
         0   -> LCD_DrawUniLine
        32   -> LCD_DrawUniLine
      24   LCD_PowerOn
        24   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        24   -> GPIO_SetBits
        24   -> GPIO_WriteBit
        24   -> LCD_WriteData
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_SendData
      16   LCD_ReSetColorKeying
        16   -> LTDC_ColorKeyingConfig
        16   -> LTDC_ReloadConfig
      40   LCD_SPIConfig
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_I2S_DeInit
        40   -> SPI_Init
       0   LCD_SetBackColor
      16   LCD_SetColorKeying
        16   -> LTDC_ColorKeyingConfig
        16   -> LTDC_ReloadConfig
       0   LCD_SetColors
       0   LCD_SetCursor
      16   LCD_SetDisplayWindow
        16   -> LTDC_LayerPosition
        16   -> LTDC_LayerSize
         0   -> LTDC_ReloadConfig
        16   -> LTDC_ReloadConfig
       0   LCD_SetFont
       0   LCD_SetLayer
       0   LCD_SetTextColor
       8   LCD_SetTransparency
         8   -> LTDC_LayerAlpha
         0   -> LTDC_ReloadConfig
      16   LCD_Triangle
         0   -> LCD_DrawUniLine
        16   -> LCD_DrawUniLine
       8   LCD_WindowModeDisable
         8   -> LTDC_LayerPosition
         8   -> LTDC_LayerSize
         0   -> LTDC_ReloadConfig
         8   -> LTDC_ReloadConfig
      48   LCD_WriteBMP
        48   -> LTDC_LayerPixelFormat
        48   -> LTDC_LayerSize
        48   -> LTDC_ReloadConfig
      16   LCD_WriteCommand
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> GPIO_WriteBit
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_SendData
      16   LCD_WriteData
        16   -> GPIO_ResetBits
         0   -> GPIO_SetBits
        16   -> GPIO_WriteBit
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable33
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable36
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
    2304  ASCII12x12_Table
    4560  ASCII16x24_Table
    2304  ASCII8x12_Table
    1536  ASCII8x8_Table
       8  Avenir
    2184  Avenir_Table
      24  CurrentTextColor
          CurrentBackColor
          LCD_Currentfonts
          CurrentFrameBuffer
          CurrentLayer
          Font16x24
       8  Font12x12
       8  Font8x12
       8  Font8x8
     346  LCD_AF_GPIOConfig
      22  LCD_ChipSelect
      20  LCD_Clear
      46  LCD_ClearLine
      36  LCD_ClosedPolyLine
       4  LCD_ClosedPolyLineRelative
      72  LCD_CtrlLinesConfig
       4  LCD_CtrlLinesWrite
     580  LCD_DeInit
      30  LCD_DisplayChar
      74  LCD_DisplayOff
      74  LCD_DisplayOn
      72  LCD_DisplayStringLine
     130  LCD_DrawChar
     126  LCD_DrawCircle
     302  LCD_DrawEllipse
     494  LCD_DrawFullCircle
     650  LCD_DrawFullEllipse
     106  LCD_DrawFullRect
     122  LCD_DrawLine
      46  LCD_DrawMonoPict
     380  LCD_DrawRect
     280  LCD_DrawUniLine
     316  LCD_FillPolyLine
     184  LCD_FillTriangle
      14  LCD_GetColors
       8  LCD_GetFont
     164  LCD_Init
     162  LCD_LayerInit
      48  LCD_PolyLine
       4  LCD_PolyLineRelative
     106  LCD_PolyLineRelativeClosed
    4242  LCD_PowerOn
      44  LCD_ReSetColorKeying
     196  LCD_SPIConfig
       8  LCD_SetBackColor
      60  LCD_SetColorKeying
      10  LCD_SetColors
      22  LCD_SetCursor
      60  LCD_SetDisplayWindow
       8  LCD_SetFont
      26  LCD_SetLayer
       8  LCD_SetTextColor
      40  LCD_SetTransparency
      58  LCD_Triangle
      58  LCD_WindowModeDisable
     270  LCD_WriteBMP
      72  LCD_WriteCommand
      72  LCD_WriteData

 
     56 bytes in section .data
 12 888 bytes in section .rodata
 10 360 bytes in section .text
 
 10 360 bytes of CODE  memory
 12 888 bytes of CONST memory
     56 bytes of DATA  memory

Errors: none
Warnings: none
