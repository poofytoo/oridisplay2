###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        23/Nov/2014  02:10:50
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\Core\Test_Program\test_program.c
#    Command line =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\Core\Test_Program\test_program.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -D USE_STM32F429I_DISCO -D
#        USE_USB_OTG_HS -D USE_EMBEDDED_PHY -lcN
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\
#        --diag_suppress Pe111,Pa082 -o
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\
#        --debug --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Config\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Devices\STM32F4xx\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\User\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Demo\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Lib\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\Core\Test_Program\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\MSC\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\HID\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_Device_Library\Class\Audio\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Common\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\STM32F429i-Discovery\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\fat_fs\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Utilities\Third_Party\FreeRTOS\Source\include\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\inc\
#        -I
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\..\..\..\Libraries\STemWinLibrary522_4x9i\Config\
#        -Ohs --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\List\test_program.lst
#    Object file  =  
#        C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\EWARM\STM32F429I-Discovery_Demo\Obj\test_program.o
#
###############################################################################

C:\Users\MichaelXu\Desktop\STM32F429I-Discovery_FW_V1.0.1\Projects\Demonstration\Core\Test_Program\test_program.c
      1          /**
      2            ******************************************************************************
      3            * @file    test_program.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    11-November-2013
      7            * @brief   Test program for STM32F429I-DISCO board
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "test_program.h"
     30          #include "image.h"
     31          #include "DIALOG.h"
     32          
     33          /** @addtogroup STM32F429I-Discovery_Demo
     34          * @{
     35          */
     36          
     37          /* Private typedef -----------------------------------------------------------*/
     38          /* Private define ------------------------------------------------------------*/
     39          /* Private macro -------------------------------------------------------------*/
     40          #define ABS(x)         (x < 0) ? (-x) : x
     41          #define L3G_Sensitivity_250dps     (float)   114.285f  /*!< gyroscope sensitivity with 250 dps full scale [LSB/dps]  */
     42          #define L3G_Sensitivity_500dps     (float)   57.1429f  /*!< gyroscope sensitivity with 500 dps full scale [LSB/dps]  */
     43          #define L3G_Sensitivity_2000dps    (float)   14.285f   /*!< gyroscope sensitivity with 2000 dps full scale [LSB/dps] */
     44          
     45          /* Private variables ---------------------------------------------------------*/
     46          #define IS42S16400J_SIZE_16             0x400000
     47          static __IO uint32_t TimingDelay;
     48          extern __IO uint32_t ButtonPressed;
     49          __ALIGN_BEGIN USB_OTG_CORE_HANDLE  USB_OTG_dev __ALIGN_END;
     50          float Buffer[6];
     51          uint8_t Xval, Yval = 0x00;
     52          L3GD20_InitTypeDef L3GD20_InitStructure;
     53          L3GD20_FilterConfigTypeDef L3GD20_FilterStructure;
     54          
     55          /* Private function prototypes -----------------------------------------------*/
     56          static void SetSYSCLK_168(void);
     57          static void SetSYSCLK_180(void);
     58          
     59          /* Private functions ---------------------------------------------------------*/
     60          
     61          /**
     62          * @brief  Main program.
     63          * @param  None
     64          * @retval None
     65          */
     66          void start_test(void)
     67          {
     68            /* Configure system clock (SYSCLK) to 180 MHz, at this stage the USB is not used.
     69               Please note that the USB is not functional if the system clock is set to 180 MHz. */
     70            SetSYSCLK_180();
     71          
     72            /* Reconfigure the SysTick following SYSCLK frequency change */
     73            if (SysTick_Config(SystemCoreClock / 1000))
     74            { 
     75              /* Capture error */ 
     76              while (1);
     77            }
     78             
     79            /* Initialize LEDs, User Button and LCD on STM32F429I-Disco */
     80            // STM_EVAL_LEDInit(LED3);
     81            // STM_EVAL_LEDInit(LED4);
     82            // STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI); 
     83            
     84            /* Display message on LCD */ 
     85            
     86            // LowLevel_Init();
     87            
     88            LCD_Init();
     89            LCD_LayerInit();
     90            
     91            // LTDC reload configuration
     92            LTDC_ReloadConfig(LTDC_IMReload);
     93            
     94            // Enable the LTDC 
     95            LTDC_Cmd(ENABLE);
     96            
     97            // Set LCD foreground layer 
     98            LCD_SetLayer(LCD_FOREGROUND_LAYER);
     99            LCD_SetTransparency(0);
    100            
    101            // Set LCD background layer 
    102            LCD_SetLayer(LCD_BACKGROUND_LAYER);
    103            
    104            // LCD display message 
    105            LCD_Clear(LCD_COLOR_BLUE);
    106            LCD_SetTextColor(LCD_COLOR_BLACK); 
    107            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"  mST PROGRAM ");
    108            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"    V1.0.1     ");
    109            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"      PUSH     ");
    110            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"  USER BUTTON  ");
    111            LCD_DisplayStringLine(LCD_LINE_9,(uint8_t*)"    TO START   ");
    112            
    113              
    114            /* Wait for User button to be pressed */
    115            //while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    116            
    117            LCD_SetTextColor(0xFF00);
    118            LCD_DrawCircle(10, 10, 10);
    119            
    120            WM_HWIN winW;
    121            
    122            GUI_Init();
    123            winW = CreateWindow();
    124            
    125            
    126            while(1)
    127            {
    128              GUI_Delay(10);
    129            }
    130            
    131            
    132            /* Wait for User button is released */
    133            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    134            {}
    135          
    136          /* SDRAM TEST *****************************************************************/  
    137            /* LCD display message */
    138            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"   SDRAM TEST  ");
    139            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"               ");  
    140            
    141            /* Wait for User button to be pressed */
    142            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    143            {}
    144            /* Wait for User button is released */
    145            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    146            {}
    147            
    148            /* SDRAM Test */
    149            SDRAM_Test();
    150          
    151          
    152          /* LCD TEST *******************************************************************/    
    153            /* LCD display message */
    154            LCD_Clear(LCD_COLOR_BLUE);
    155            LCD_SetTextColor(LCD_COLOR_BLACK); 
    156            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"    LCD TEST   ");
    157            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    158            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    159            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"    TO START   ");
    160            
    161            /* Wait for User button to be pressed */
    162            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    163            {}
    164            /* Wait for User button is released */
    165            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    166            {}
    167            
    168            /* LCD Test */
    169            LCD_Test();
    170          
    171          /* TP TEST ********************************************************************/  
    172            /* LCD display message */
    173            LCD_Clear(LCD_COLOR_BLUE);
    174            LCD_SetTextColor(LCD_COLOR_BLACK); 
    175            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"     TP TEST   ");
    176            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    177            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    178            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"    TO START   ");
    179            
    180            /* Wait for User button to be pressed */
    181            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    182            { }
    183            /* Wait for User button is released */
    184            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    185            { }
    186            
    187            /* TS Test */
    188            TP_Test();
    189          
    190          /* MEMS TEST ******************************************************************/  
    191            /* LCD display message */
    192            LCD_Clear(LCD_COLOR_BLUE);
    193            LCD_SetTextColor(LCD_COLOR_BLACK); 
    194            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"   MEMS TEST   ");
    195            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"     PUSH      ");
    196            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    197            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"    TO START   ");
    198            
    199            /* Wait for User button to be pressed */
    200            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    201            { }
    202            /* Wait for User button is released */
    203            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    204            { }
    205            
    206            /* Configure Mems L3GD20*/
    207            Demo_GyroConfig();
    208            
    209            /* Mems Test */
    210            MEMS_Test();  
    211          
    212          /* USB TEST *******************************************************************/  
    213            /* LCD display message */
    214            LCD_Clear(LCD_COLOR_BLUE);
    215            LCD_SetTextColor(LCD_COLOR_BLACK); 
    216            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"    USB TEST   ");
    217            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    218            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    219            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"    TO START   ");
    220            
    221            /* Wait for User button to be pressed */
    222            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    223            {}
    224            /* Wait for User button is released */
    225            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    226            {}
    227          
    228            /* Configure system clock (SYSCLK) to 168 MHz to provide 48 MHz clock needed for
    229               the USB operation.
    230               Please note that the USB is not functional if the system clock is set to 180 MHz. */
    231            SetSYSCLK_168();
    232          
    233            /* Reconfigure the SysTick following SYSCLK frequency change */
    234            if (SysTick_Config(SystemCoreClock / 1000))
    235            { 
    236              /* Capture error */ 
    237              while (1);
    238            }  
    239            /* USB Test */
    240            USB_Test();  
    241          
    242          
    243          /* End of test program: go to infinite loop ***********************************/
    244            LCD_Clear(LCD_COLOR_BLUE);
    245            LCD_SetTextColor(LCD_COLOR_BLACK); 
    246            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  End Of Test  ");
    247            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"   Program     ");
    248           
    249            while (1)
    250            {   
    251            }
    252          }
    253          
    254          /**
    255          * @brief   Detect motion direction to test MEMS.
    256          * @param  None
    257          * @retval None
    258          */
    259          void MEMS_Test(void)
    260          {  
    261            
    262            /* LCD display message */
    263            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"MOVE DISCOVERY ");
    264            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"If screen color");
    265            LCD_DisplayStringLine(LCD_LINE_6,(uint8_t*)"changes:Test OK");
    266            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"Else Test KO   ");
    267          
    268           
    269            /* Wait for User button to be pressed */
    270            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET)
    271            {
    272              /* Read Gyro Angular data */
    273              Demo_GyroReadAngRate(Buffer);
    274              
    275              /* Update autoreload and capture compare registers value*/
    276              Xval = ABS((int8_t)(Buffer[0]));
    277              Yval = ABS((int8_t)(Buffer[1]));   
    278              if ( Xval>Yval)
    279              {
    280                if ((int8_t)Buffer[0] > 10.0f)
    281                { 
    282                  /* LED3 and LED4 On */
    283                  STM_EVAL_LEDOn(LED3);
    284                  STM_EVAL_LEDOn(LED4);
    285                  
    286                  /* Clear the LCD */ 
    287                  LCD_Clear(LCD_COLOR_BLUE);
    288                  LCD_DisplayStringLine(LCD_LINE_10,(uint8_t*)"   PUSH USER    ");
    289                  LCD_DisplayStringLine(LCD_LINE_11,(uint8_t*)"  BUTTON TO GO  ");
    290                  LCD_DisplayStringLine(LCD_LINE_12,(uint8_t*)"  TO NEXT TEST  ");
    291                  Delay(200);
    292                }
    293                if ((int8_t)Buffer[0] < -10.0f)
    294                { 
    295                  /* LED3 and LED4 Off */
    296                  STM_EVAL_LEDOff(LED3);
    297                  STM_EVAL_LEDOff(LED4);
    298                  /* Clear the LCD */ 
    299                  LCD_Clear(LCD_COLOR_WHITE); 
    300                  LCD_DisplayStringLine(LCD_LINE_10,(uint8_t*)"   PUSH USER    ");
    301                  LCD_DisplayStringLine(LCD_LINE_11,(uint8_t*)"  BUTTON TO GO  ");
    302                  LCD_DisplayStringLine(LCD_LINE_12,(uint8_t*)"  TO NEXT TEST  ");
    303                  Delay(200);
    304                }
    305              }
    306              else
    307              {
    308                if ((int8_t)Buffer[1] < -10.0f)
    309                {
    310                  /* LED4 On */
    311                  STM_EVAL_LEDOff(LED3);
    312                  STM_EVAL_LEDOn(LED4);
    313                  
    314                  /* Clear the LCD */ 
    315                  LCD_Clear(LCD_COLOR_RED);
    316                  LCD_DisplayStringLine(LCD_LINE_10,(uint8_t*)"   PUSH USER    ");
    317                  LCD_DisplayStringLine(LCD_LINE_11,(uint8_t*)"  BUTTON TO GO  ");
    318                  LCD_DisplayStringLine(LCD_LINE_12,(uint8_t*)"  TO NEXT TEST  ");          
    319                  Delay(200);
    320                }
    321                if ((int8_t)Buffer[1] > 10.0f)
    322                {
    323                  /* LED3 On */
    324                  STM_EVAL_LEDOff(LED4);
    325                  STM_EVAL_LEDOn(LED3);
    326                  
    327                  /* Clear the LCD */ 
    328                  LCD_Clear(LCD_COLOR_GREEN);
    329                  LCD_DisplayStringLine(LCD_LINE_10,(uint8_t*)"   PUSH USER    ");
    330                  LCD_DisplayStringLine(LCD_LINE_11,(uint8_t*)"  BUTTON TO GO  ");
    331                  LCD_DisplayStringLine(LCD_LINE_12,(uint8_t*)"  TO NEXT TEST  ");        
    332                  Delay(200);
    333                } 
    334              }
    335            }
    336            /* Wait for User button is released */
    337            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    338            {}
    339            /* LED3 and LED4 Off */
    340            STM_EVAL_LEDOff(LED3);
    341            STM_EVAL_LEDOff(LED4);
    342          }
    343          
    344          /**
    345          * @brief  Detect screen touch in specific square.
    346          * @param  None
    347          * @retval None
    348          */
    349          void TP_Test(void)
    350          {
    351            static TP_STATE* TP_State; 
    352            
    353            /* Clear the LCD */ 
    354            LCD_Clear(LCD_COLOR_BLUE2);
    355            
    356            /* Configure the IO Expander */
    357            if (IOE_Config() == IOE_OK)
    358            {
    359              /* Update the structure with the current position */
    360              TP_State = IOE_TP_GetState();  
    361              
    362              while (!(TP_State->TouchDetected) )
    363              {
    364                LCD_SetTextColor(LCD_COLOR_RED); 
    365                LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"  PLEASE TOUCH ");
    366                LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  THE SCREEN   ");
    367                LCD_DrawFullRect(80, 200, 80, 80);       
    368                TP_State = IOE_TP_GetState(); 
    369                TP_State->X = TP_State->X;
    370                TP_State->Y = TP_State->Y;
    371                if ((TP_State->TouchDetected) && (TP_State->Y < 280) && (TP_State->Y > 200) && (TP_State->X > 80) && (TP_State->X < 160))
    372                {
    373                  /* LCD display message */ 
    374                  LCD_Clear(LCD_COLOR_GREEN);
    375                  LCD_SetTextColor(LCD_COLOR_BLACK); 
    376                  LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"   TP TEST OK  ");
    377                  LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    378                  LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    379                  /* Waiting User Button is pressed */
    380                  while ((STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET))
    381                  {}      
    382                  /* Wait for User button is released */
    383                  while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    384                  { }
    385                }
    386                else
    387                {
    388                  TP_State->TouchDetected = 0;
    389                }
    390              }
    391            }  
    392            else
    393            {
    394              /* LCD display message */
    395              LCD_Clear(LCD_COLOR_RED);
    396              LCD_SetTextColor(LCD_COLOR_BLACK); 
    397              LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"   TS TEST     ");
    398              LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"    FAILED     ");
    399              
    400              /* Waiting User Button is pressed */
    401              while ((STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET))
    402              {}      
    403              /* Wait for User Button is released */
    404              while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    405              { } 
    406            }
    407          }
    408          
    409          /**
    410          * @brief  Display image on LCD.
    411          * @param  None
    412          * @retval None
    413          */
    414          void LCD_Test(void)
    415          { 
    416            DMA2D_InitTypeDef              DMA2D_InitStruct;
    417            DMA2D_FG_InitTypeDef           DMA2D_FG_InitStruct;
    418            
    419            /* Transfer data from SDRAM to Graphics RAM using DMA2D */
    420            /* Memory to Memory Transfer */
    421            DMA2D_DeInit();
    422            DMA2D_InitStruct.DMA2D_Mode = DMA2D_M2M;       
    423            DMA2D_InitStruct.DMA2D_CMode = DMA2D_RGB565;      
    424            DMA2D_InitStruct.DMA2D_OutputGreen = 0x0;      
    425            DMA2D_InitStruct.DMA2D_OutputBlue = 0x00;     
    426            DMA2D_InitStruct.DMA2D_OutputRed = 0x00;                
    427            DMA2D_InitStruct.DMA2D_OutputAlpha = 0x0;                  
    428            DMA2D_InitStruct.DMA2D_OutputMemoryAdd = 0xD0000000;                
    429            DMA2D_InitStruct.DMA2D_OutputOffset = 0x0;                
    430            DMA2D_InitStruct.DMA2D_NumberOfLine = 320;            
    431            DMA2D_InitStruct.DMA2D_PixelPerLine = 240;
    432            DMA2D_Init(&DMA2D_InitStruct);   
    433            DMA2D_FG_InitStruct.DMA2D_FGMA = (uint32_t)&Image;
    434            DMA2D_FG_InitStruct.DMA2D_FGO = 0x00;
    435            DMA2D_FG_InitStruct.DMA2D_FGCM = CM_RGB565;
    436            DMA2D_FG_InitStruct.DMA2D_FGPFC_ALPHA_VALUE = 0x00;
    437            DMA2D_FG_InitStruct.DMA2D_FGC_BLUE = 0x00;
    438            DMA2D_FG_InitStruct.DMA2D_FGC_GREEN = 0x00;
    439            DMA2D_FG_InitStruct.DMA2D_FGC_RED = 0x00;
    440            DMA2D_FGConfig(&DMA2D_FG_InitStruct);
    441            
    442            /* Start Transfer */ 
    443            DMA2D_StartTransfer();
    444            
    445            /* LTDC configuration reload */  
    446            LTDC_ReloadConfig(LTDC_IMReload);
    447            
    448            /* Wait for TC Flag activation */
    449            while(DMA2D_GetFlagStatus(DMA2D_FLAG_TC) == RESET)
    450            {}
    451          
    452            /* Add some delay to have the image visible for 1.5s */
    453            Delay (1500);
    454            
    455            /* Clear the LCD */ 
    456            LCD_Clear(LCD_COLOR_GREEN);
    457            LCD_SetTextColor(LCD_COLOR_BLACK); 
    458            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"  LCD TEST OK  ");
    459            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    460            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    461            /* Waiting User Button is pressed */
    462            while ((STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET))
    463            {}
    464            /* Wait for User Button is released */
    465            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    466            {}
    467          }
    468          
    469          /**
    470          * @brief  USB Test : LED5 ON  when USB OK and connected to PC.
    471          * @param  None
    472          * @retval None
    473          */
    474          void USB_Test(void)
    475          {     
    476          
    477            /* Init Device Library ********************************************************/
    478            USBD_Init(&USB_OTG_dev,
    479                      USB_OTG_HS_CORE_ID,
    480                      &USR_desc, 
    481                      &USBD_HID_cb, 
    482                      &USR_cb);   
    483            
    484            /* Connect USB to PC/Laptop, if LED5 is ON test OK, otherwise NotOK */
    485            /* LCD display message */
    486            LCD_Clear(LCD_COLOR_GREEN);
    487            LCD_SetTextColor(LCD_COLOR_BLACK); 
    488            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)" CONNECT USB   ");
    489            LCD_DisplayStringLine(LCD_LINE_2,(uint8_t*)"USER CN6 TO PC ");
    490            LCD_DisplayStringLine(LCD_LINE_4,(uint8_t*)"If LED5 ON:    ");
    491            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"    TEST OK    ");
    492            LCD_DisplayStringLine(LCD_LINE_7,(uint8_t*)"If LED5 OFF:   ");
    493            LCD_DisplayStringLine(LCD_LINE_8,(uint8_t*)"    TEST KO    ");
    494            LCD_DisplayStringLine(LCD_LINE_10,(uint8_t*)"      PUSH     ");
    495            LCD_DisplayStringLine(LCD_LINE_11,(uint8_t*)"  USER BUTTON  ");
    496            
    497            /* Waiting User Button is pressed */
    498            while ((STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET))
    499            {}      
    500            /* Wait for User Button is released */
    501            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    502            { }   
    503          }
    504          
    505          /**
    506          * @brief  Erase, then write/read operation are performed to test SDRAM.
    507          * @param  None
    508          * @retval None
    509          */
    510          void SDRAM_Test(void)
    511          {
    512            uint16_t writedata_16b = 0x1E5A, readdata_16b = 0;  
    513            uint32_t readwritestatus = 0;
    514            uint32_t index = 0;
    515            
    516            /* SDRAM Initialization */  
    517            SDRAM_Init();
    518            
    519            /* FMC SDRAM GPIOs Configuration*/
    520            SDRAM_GPIOConfig(); 
    521            
    522            /* Disable write protection */
    523            FMC_SDRAMWriteProtectionConfig(FMC_Bank2_SDRAM,DISABLE); 
    524            
    525            /* Erase SDRAM memory */
    526            for (index = 0x00; index < IS42S16400J_SIZE_16; index++)
    527            {
    528              *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*index) = (uint16_t)0x00;
    529            }
    530            
    531            /* Write data value to all SDRAM memory */
    532            for (index = 0; index < IS42S16400J_SIZE_16; index++)
    533            {
    534              *(__IO uint16_t*) (SDRAM_BANK_ADDR + 2*index) = (uint16_t)(writedata_16b + index);
    535            }
    536            
    537            /* Read back SDRAM memory and check content correctness*/
    538            index = 0;
    539            readwritestatus = 0;
    540            while ((index < IS42S16400J_SIZE_16) && (readwritestatus == 0))
    541            {
    542              readdata_16b = *(__IO uint16_t*)(SDRAM_BANK_ADDR + 2*index);
    543              if ( readdata_16b != (uint16_t)(writedata_16b + index))
    544              {
    545                readwritestatus = 1;
    546                STM_EVAL_LEDOn(LED4);
    547                STM_EVAL_LEDOff(LED3); 
    548                /* LCD display ERROR message */
    549                LCD_Clear(LCD_COLOR_RED);
    550                LCD_SetTextColor(LCD_COLOR_BLACK); 
    551                LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)"   SDRAM TEST  ");
    552                LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"    FAILED     ");
    553                /*infinite loop on memory error.*/
    554                while(1)
    555                {
    556                  Delay(100);
    557                  STM_EVAL_LEDToggle(LED4);
    558                }      
    559              }
    560              else
    561              {
    562                STM_EVAL_LEDOn(LED3);
    563              }
    564              index++;
    565            }
    566               /* LCD display OK message */ 
    567            LCD_Clear(LCD_COLOR_GREEN);
    568            LCD_SetTextColor(LCD_COLOR_BLACK); 
    569            LCD_DisplayStringLine(LCD_LINE_1,(uint8_t*)" SDRAM TEST OK ");
    570            LCD_DisplayStringLine(LCD_LINE_3,(uint8_t*)"      PUSH     ");
    571            LCD_DisplayStringLine(LCD_LINE_5,(uint8_t*)"  USER BUTTON  ");
    572             /* Waiting User Button is pressed */
    573            while ((STM_EVAL_PBGetState(BUTTON_USER) != Bit_SET))
    574            {}
    575            /* Wait for User button is released */
    576            while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
    577            { }
    578             
    579            /* Turn Off Leds */ 
    580            STM_EVAL_LEDOff(LED3);
    581            STM_EVAL_LEDOff(LED4);  
    582          }
    583          
    584          /**
    585          * @brief  Configure the Mems to gyroscope application.
    586          * @param  None
    587          * @retval None
    588          */
    589          void Demo_GyroConfig(void)
    590          {
    591            /* Configure Mems L3GD20 */
    592            L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
    593            L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
    594            L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
    595            L3GD20_InitStructure.Band_Width = L3GD20_BANDWIDTH_4;
    596            L3GD20_InitStructure.BlockData_Update = L3GD20_BlockDataUpdate_Continous;
    597            L3GD20_InitStructure.Endianness = L3GD20_BLE_LSB;
    598            L3GD20_InitStructure.Full_Scale = L3GD20_FULLSCALE_500; 
    599            L3GD20_Init(&L3GD20_InitStructure);
    600            L3GD20_FilterStructure.HighPassFilter_Mode_Selection =L3GD20_HPM_NORMAL_MODE_RES;
    601            L3GD20_FilterStructure.HighPassFilter_CutOff_Frequency = L3GD20_HPFCF_0;
    602            L3GD20_FilterConfig(&L3GD20_FilterStructure) ;
    603            L3GD20_FilterCmd(L3GD20_HIGHPASSFILTER_ENABLE);
    604          }
    605          
    606          /**
    607          * @brief  Calculate the angular Data rate Gyroscope.
    608          * @param  pfData : Data out pointer
    609          * @retval None
    610          */
    611          void Demo_GyroReadAngRate (float* pfData)
    612          {
    613            uint8_t tmpbuffer[6] ={0};
    614            int16_t RawData[3] = {0};
    615            uint8_t tmpreg = 0;
    616            float sensitivity = 0;
    617            int i =0;
    618            
    619            L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
    620            L3GD20_Read(tmpbuffer,L3GD20_OUT_X_L_ADDR,6);
    621            
    622            /* check in the control register 4 the data alignment (Big Endian or Little Endian)*/
    623            if(!(tmpreg & 0x40))
    624            {
    625              for(i=0; i<3; i++)
    626              {
    627                RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i+1] << 8) + tmpbuffer[2*i]);
    628              }
    629            }
    630            else
    631            {
    632              for(i=0; i<3; i++)
    633              {
    634                RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i] << 8) + tmpbuffer[2*i+1]);
    635              }
    636            }
    637            
    638            /* Switch the sensitivity value set in the CRTL4 */
    639            switch(tmpreg & 0x30)
    640            {
    641            case 0x00:
    642              sensitivity=L3G_Sensitivity_250dps;
    643              break;
    644              
    645            case 0x10:
    646              sensitivity=L3G_Sensitivity_500dps;
    647              break;
    648              
    649            case 0x20:
    650              sensitivity=L3G_Sensitivity_2000dps;
    651              break;
    652            }
    653            /* divide by sensitivity */
    654            for(i=0; i<3; i++)
    655            {
    656              pfData[i]=(float)RawData[i]/sensitivity;
    657            }
    658          }
    659          
    660          /**
    661          * @brief  Basic management of the timeout situation.
    662          * @param  None.
    663          * @retval None.
    664          */
    665          uint32_t L3GD20_TIMEOUT_UserCallback(void)
    666          {
    667            return 0;
    668          }
    669          
    670          /**
    671          * @brief  Inserts a delay time.
    672          * @param  nTime: specifies the delay time length, in 10 ms.
    673          * @retval None
    674          */
    675          void Delay(__IO uint32_t nTime)
    676          {
    677            TimingDelay = nTime; 
    678            while(TimingDelay != 0);
    679          }
    680          
    681          /**
    682          * @brief  Decrements the TimingDelay variable.
    683          * @param  None
    684          * @retval None
    685          */
    686          void TimingDelay_Decrement(void)
    687          {
    688            if (TimingDelay != 0x00)
    689            { 
    690              TimingDelay--;
    691            }
    692          }
    693          
    694          
    695          /**
    696          * @brief  Configures System clock to 180 MHz.
    697          * @param  None
    698          * @retval None
    699          */
    700          static void SetSYSCLK_180(void)
    701          {
    702            /* Select HSE as system clock source */
    703            RCC_SYSCLKConfig(RCC_SYSCLKSource_HSE);
    704            
    705            /* Wait till HSE is used as system clock source */
    706            while (RCC_GetSYSCLKSource() != 0x04)
    707            {}
    708            
    709            /* Disable PLL */
    710            RCC_PLLCmd(DISABLE);  
    711            
    712            /* Configure PLL clock to have:
    713            PLL_VCO = (HSE_VALUE / PLL_M) * PLL_N = 360 MHz
    714            SYSCLK = PLL_VCO / PLL_P = 180 MHz
    715            USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ = ~51 MHz (USB is not used)
    716            */
    717            RCC_PLLConfig(RCC_PLLSource_HSE, 
    718                          8, //PLLM
    719                          360, //PLLN
    720                          2, //PLLP
    721                          7 //PLLQ
    722                            );
    723            
    724            /* Enable PLL */
    725            RCC_PLLCmd(ENABLE);
    726            
    727            /* Wait till PLL is ready */
    728            while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
    729            {}
    730            
    731            /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
    732            PWR_OverDriveCmd(ENABLE);
    733              
    734            /* Wait till Over-drive is ready */
    735            while (PWR_GetFlagStatus(PWR_FLAG_ODRDY) == RESET)
    736            {}
    737            /* Enable the Over-drive mode switching to extend the clock frequency to 180 Mhz */
    738            PWR_OverDriveSWCmd(ENABLE);
    739              
    740            /* Wait till Over-drive mode switching is ready */
    741            while (PWR_GetFlagStatus(PWR_FLAG_ODSWRDY) == RESET)
    742            {}
    743            
    744            /* Select PLL as system clock source */
    745            RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    746            
    747            /* Wait till PLL is used as system clock source */
    748            while (RCC_GetSYSCLKSource() != 0x08)
    749            {}
    750            
    751            /* Update SystemCoreClock global variable value */
    752            SystemCoreClock = 180000000;
    753          }
    754          
    755          
    756          /**
    757          * @brief  Configures System clock to 168 MHz, to have USB clocked at 48 MHz.
    758          * @param  None
    759          * @retval None
    760          */
    761          static void SetSYSCLK_168(void)
    762          {  
    763            /* Select HSE as system clock source */
    764            RCC_SYSCLKConfig(RCC_SYSCLKSource_HSE);
    765            
    766            /* Wait till HSE is used as system clock source */
    767            while (RCC_GetSYSCLKSource() != 0x04)
    768            {}
    769            
    770            /* Disable PLL */
    771            RCC_PLLCmd(DISABLE);  
    772          
    773            /* Disable Over-drive mode */
    774            PWR_OverDriveCmd(DISABLE);    
    775            PWR_OverDriveSWCmd(DISABLE);
    776              
    777            /* Wait till ODSWRDY is reset */
    778            while (PWR_GetFlagStatus(PWR_FLAG_ODSWRDY) != RESET)
    779            {}
    780              
    781            /* Configure PLL clock to have:
    782            PLL_VCO = (HSE_VALUE / PLL_M) * PLL_N = 336 MHz
    783            SYSCLK = PLL_VCO / PLL_P = 168 MHz
    784            USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ = 48 MHz
    785            */
    786            RCC_PLLConfig(RCC_PLLSource_HSE, 
    787                          8, //PLLM
    788                          336, //PLLN
    789                          2, //PLLP
    790                          7 //PLLQ
    791                            );
    792            
    793            /* Enable PLL */
    794            RCC_PLLCmd(ENABLE);  
    795            
    796            /* Wait till PLL is ready */
    797            while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
    798            {}
    799            
    800            /* Select PLL as system clock source */
    801            RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    802            
    803            /* Wait till PLL is used as system clock source */
    804            while (RCC_GetSYSCLKSource() != 0x08)
    805            {} 
    806            
    807            /* Update SystemCoreClock global variable value */
    808            SystemCoreClock = 168000000;
    809          }
    810          
    811          /**
    812          * @}
    813          */
    814          
    815          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   Delay
       8   Demo_GyroConfig
         0   -> L3GD20_FilterCmd
         8   -> L3GD20_FilterConfig
         8   -> L3GD20_Init
      48   Demo_GyroReadAngRate
        48   -> L3GD20_Read
       0   L3GD20_TIMEOUT_UserCallback
      96   LCD_Test
        96   -> DMA2D_DeInit
        96   -> DMA2D_FGConfig
        96   -> DMA2D_GetFlagStatus
        96   -> DMA2D_Init
        96   -> DMA2D_StartTransfer
        96   -> LCD_Clear
        96   -> LCD_DisplayStringLine
        96   -> LCD_GetFont
        96   -> LCD_SetTextColor
        96   -> LTDC_ReloadConfig
        96   -> STM_EVAL_PBGetState
      40   MEMS_Test
        40   -> Demo_GyroReadAngRate
        40   -> LCD_Clear
        40   -> LCD_DisplayStringLine
        40   -> LCD_GetFont
         0   -> STM_EVAL_LEDOff
        40   -> STM_EVAL_LEDOff
        40   -> STM_EVAL_LEDOn
        40   -> STM_EVAL_PBGetState
      24   SDRAM_Test
        24   -> FMC_SDRAMWriteProtectionConfig
        24   -> LCD_Clear
        24   -> LCD_DisplayStringLine
        24   -> LCD_GetFont
        24   -> LCD_SetTextColor
        24   -> SDRAM_GPIOConfig
        24   -> SDRAM_Init
         0   -> STM_EVAL_LEDOff
        24   -> STM_EVAL_LEDOff
        24   -> STM_EVAL_LEDOn
        24   -> STM_EVAL_LEDToggle
        24   -> STM_EVAL_PBGetState
      32   TP_Test
        32   -> IOE_Config
        32   -> IOE_TP_GetState
        32   -> LCD_Clear
        32   -> LCD_DisplayStringLine
        32   -> LCD_DrawFullRect
        32   -> LCD_GetFont
        32   -> LCD_SetTextColor
        32   -> STM_EVAL_PBGetState
       0   TimingDelay_Decrement
       8   USB_Test
         8   -> LCD_Clear
         8   -> LCD_DisplayStringLine
         8   -> LCD_GetFont
         8   -> LCD_SetTextColor
         8   -> STM_EVAL_PBGetState
         8   -> USBD_Init
       8   start_test
         8   -> CreateWindow
         8   -> GUI_Delay
         8   -> GUI_Init
         8   -> LCD_Clear
         8   -> LCD_DisplayStringLine
         8   -> LCD_DrawCircle
         8   -> LCD_GetFont
         8   -> LCD_Init
         8   -> LCD_LayerInit
         8   -> LCD_SetLayer
         8   -> LCD_SetTextColor
         8   -> LCD_SetTransparency
         8   -> LTDC_Cmd
         8   -> LTDC_ReloadConfig
         8   -> PWR_GetFlagStatus
         8   -> PWR_OverDriveCmd
         8   -> PWR_OverDriveSWCmd
         8   -> RCC_GetFlagStatus
         8   -> RCC_GetSYSCLKSource
         8   -> RCC_PLLCmd
         8   -> RCC_PLLConfig
         8   -> RCC_SYSCLKConfig


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable38
        4  ??DataTable38_1
        4  ??DataTable38_10
        4  ??DataTable38_11
        4  ??DataTable38_12
        4  ??DataTable38_13
        4  ??DataTable38_14
        4  ??DataTable38_2
        4  ??DataTable38_3
        4  ??DataTable38_4
        4  ??DataTable38_5
        4  ??DataTable38_6
        4  ??DataTable38_7
        4  ??DataTable38_8
        4  ??DataTable38_9
       16  ?_0
       16  ?_1
       20  ?_10
       20  ?_11
       20  ?_12
       16  ?_13
       16  ?_14
       16  ?_15
       16  ?_16
       16  ?_17
       16  ?_18
       16  ?_19
       16  ?_2
       16  ?_20
       16  ?_21
       16  ?_22
       16  ?_23
       16  ?_24
       16  ?_25
        8  ?_26
        8  ?_27
       16  ?_3
       16  ?_4
       16  ?_5
       16  ?_6
       16  ?_7
       16  ?_8
       16  ?_9
       32  Buffer
           Xval
           Yval
           TimingDelay
       18  Delay
       56  Demo_GyroConfig
      196  Demo_GyroReadAngRate
   153600  Image
       12  L3GD20_InitStructure
           L3GD20_FilterStructure
        4  L3GD20_TIMEOUT_UserCallback
      212  LCD_Test
      624  MEMS_Test
      278  SDRAM_Test
        4  TP_State
      302  TP_Test
       14  TimingDelay_Decrement
     2704  USB_OTG_dev
      210  USB_Test
      328  start_test

 
   2 752 bytes in section .bss
      16 bytes in section .rodata
 156 330 bytes in section .text
 
 156 330 bytes of CODE  memory
      16 bytes of CONST memory
   2 752 bytes of DATA  memory

Errors: none
Warnings: 3
